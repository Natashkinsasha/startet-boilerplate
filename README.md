# starter-boilerplate

Go starter project for bootstrapping new services.

---

## Stack

| Component      | Library                               |
|----------------|---------------------------------------|
| HTTP server    | `net/http` (stdlib)                   |
| OpenAPI / REST | `github.com/danielgtaylor/huma/v2`    |
| ORM            | `github.com/uptrace/bun` (PostgreSQL) |
| Cache          | `github.com/redis/go-redis/v9`        |
| Configuration  | `gopkg.in/yaml.v3`                    |
| Migrations     | `bun/migrate`                         |
| Logging        | `go.uber.org/zap`                     |
| Authentication | `github.com/golang-jwt/jwt/v5`        |
| gRPC           | `google.golang.org/grpc` + `protobuf` |
| DI             | `github.com/google/wire`              |
| Testing        | `github.com/testcontainers/testcontainers-go` |
| Infrastructure | Docker + docker-compose               |

---

## Project layout

```
starter-boilerplate/
├── cmd/
│   ├── api/
│   │   └── main.go              # entry point: signal → InitializeApp → app.Run
│   ├── migrate/
│   │   └── main.go              # DB migration CLI (init, migrate, rollback, status, create)
│   └── swagger/
│       └── main.go              # OpenAPI spec generation
│
├── internal/
│   ├── initialize.go        # Wire injector (//go:build wireinject)
│   ├── wire_gen.go          # generated by: wire gen ./...
│   ├── shared/              # infrastructure reused across all subdomains
│   │   ├── app/
│   │   │   └── app.go       # App struct, New(), Run(), shutdown()
│   │   ├── config/
│   │   │   └── setup.go     # SetupConfig() → *Config; assembles Config from sub-pkg types
│   │   ├── db/
│   │   │   └── setup.go     # DBConfig; Setup(DBConfig, *zap.Logger) → *bun.DB
│   │   ├── redis/
│   │   │   └── setup.go     # RedisConfig; Setup(RedisConfig, *zap.Logger) → *goredis.Client
│   │   ├── server/
│   │   │   └── setup.go     # SetupMux() → *http.ServeMux; SetupHTTPServer() → *http.Server
│   │   ├── huma/
│   │   │   └── setup.go     # Setup(*http.ServeMux, AppConfig) → huma.API
│   │   ├── middleware/
│   │   │   └── setup.go     # Setup(*http.Server, huma.API, *jwt.Manager) → Init
│   │   ├── logger/
│   │   │   └── logger.go    # LoggerConfig; SetupLogger(LoggerConfig) → *zap.Logger
│   │   ├── jwt/
│   │   │   └── jwt.go       # JWTConfig; NewJWTManager(JWTConfig) → *pkgjwt.Manager
│   │   ├── grpc/
│   │   │   └── setup.go     # GRPCConfig; Setup(GRPCConfig, *zap.Logger) → *grpc.Server
│   │   └── migrate/
│   │       └── runner.go    # Runner; wraps bun/migrate.Migrator
│   │
│   └── user/                # subdomain (user + auth combined)
│       ├── domain/
│       │   ├── model/
│       │   │   └── user.go          # User, TokenPair
│       │   └── repository/
│       │       └── user.go          # UserRepository (interface)
│       ├── app/
│       │   └── service/
│       │       └── auth.go          # AuthService struct
│       ├── transport/
│       │   ├── handler/
│       │   │   └── auth/
│       │   │       ├── handler.go   # Handler struct, SetupHandler()
│       │   │       ├── login.go     # registerLogin(), login()
│       │   │       ├── refresh.go   # registerRefresh(), refresh()
│       │   │       └── types.go     # tokenBody, tokenOutput
│       │   └── contract/
│       │       └── user/
│       │           ├── contract.go  # Contract struct, SetupContract()
│       │           └── get_user.go  # GetUser()
│       ├── infra/
│       │   └── persistence/
│       │       └── user.go          # userRepository — implements UserRepository
│       ├── initialize.go            # Wire injector: Module, InitializeUserModule
│       └── wire_gen.go              # generated
│
├── pkg/                     # reusable code, no dependency on internal/
│   ├── jwt/
│   │   └── manager.go       # Manager, Claims, Config; token generation and validation
│   └── logger/
│       └── setup.go         # Logger (= zap.Logger); SetupLogger(format, level); NewNop()
│
├── proto/                   # Protobuf definitions (.proto files)
├── gen/                     # generated code from proto (DO NOT edit)
├── migrations/              # SQL migrations (bun/migrate)
│   ├── embed.go             # //go:embed *.sql → var Migrations
│   └── *.sql                # {timestamp}_{name}.up.sql / .down.sql
├── env/
│   ├── .env.yaml            # base values
│   ├── .env.{APP_ENV}.yaml  # environment override (loaded if APP_ENV is set)
│   └── .env.standalone.yaml # standalone mode (DB/Redis disabled)
├── docker-compose.yml
├── Makefile
└── go.mod                   # module: starter-boilerplate
```

---

## Architectural rules

### Subdomain layers

```
transport/handler  →  app/service  ←  infra/persistence
        ↓                  ↓                   ↓
   domain/repository  (interfaces)    domain/model (entities)
```

| Layer             | Package                | Depends on                                         |
|-------------------|------------------------|----------------------------------------------------|
| Entities / DTOs   | `domain/model`         | nothing external                                   |
| Interfaces        | `domain/repository`    | `domain/model`                                     |
| Business logic    | `app/service`          | `domain/repository`, `domain/model`, `pkg/jwt`     |
| HTTP handlers     | `transport/handler`    | `domain/repository`, `domain/model`                |
| Repository impl   | `infra/persistence`    | `domain/repository`, `domain/model`, `bun`         |

### Package naming

Each package is named after its directory — no aliases needed:

```
internal/user/domain/model/            → package model
internal/user/domain/repository/       → package repository
internal/user/app/service/             → package service
internal/user/transport/handler/auth/  → package auth
internal/user/transport/contract/user/ → package user
internal/user/infra/persistence/       → package persistence
```

```go
import (
    "starter-boilerplate/internal/user/domain/model"
    "starter-boilerplate/internal/user/domain/repository"
    "starter-boilerplate/internal/user/app/service"
    "starter-boilerplate/internal/user/infra/persistence"
)
```

### Function naming

| Prefix               | Purpose                                          | Returns error     |
|----------------------|--------------------------------------------------|-------------------|
| `New...`             | Pure constructor, only creates an object         | yes, if needed    |
| `Setup...`           | Creates object + invokes methods (side effects)  | **no — panic**    |
| `Initialize...Module`| Wire injector — wires subdomain dependencies     | yes               |

**`Setup*` never returns an error** — on critical failure it calls `panic`.

### Visibility (exported / unexported)

Repository implementations in `infra/` are **unexported**:
```go
type userRepository struct{ db *bun.DB }  // infra/persistence
```

Constructors (`New...`) are **exported** — required by Wire.

Internal helpers and types are **unexported**:
```go
func (d DBConfig) dsn() string { ... }  // used only inside db/setup.go
type tokenType string                    // used only inside pkg/jwt
```

### Handlers

Each handler group is a separate package (e.g. `transport/handler/auth/`).
One file = one endpoint (input type, registration, handler method).

`SetupHandler(api, ...)` creates the handler and registers all routes:
```go
// handler.go
func SetupHandler(api huma.API, as *service.AuthService) *Handler {
    h := &Handler{as: as}
    h.registerLogin(api)
    h.registerRefresh(api)
    return h
}

// login.go
func (h *Handler) registerLogin(api huma.API) {
    huma.Register(api, huma.Operation{...}, h.login)
}

func (h *Handler) login(ctx context.Context, input *loginInput) (*tokenOutput, error) { ... }
```
HTTP methods (`login`, `refresh`) and registration methods are **unexported**.

---

## Configuration

### Principle: config lives next to its tool

Each `internal/shared/*` package defines its **own** config type. `config/setup.go` reads YAML files and assembles the root `*Config`.

```
internal/shared/db/setup.go      → type DBConfig struct
internal/shared/redis/setup.go   → type RedisConfig struct
internal/shared/jwt/jwt.go       → type JWTConfig struct
internal/shared/logger/logger.go → type LoggerConfig struct
internal/shared/grpc/setup.go    → type GRPCConfig struct
internal/shared/config/setup.go  → type Config struct  (aggregates all)
```

Dependency direction:
```
config  →  db, redis, jwt, logger, grpc    (config imports them, not the other way around)
```

### Structs

```go
// internal/shared/config/setup.go
type AppConfig struct {
    Port            int           `yaml:"port" validate:"required"`
    ReadTimeout     time.Duration `yaml:"read_timeout" validate:"required"`
    WriteTimeout    time.Duration `yaml:"write_timeout" validate:"required"`
    IdleTimeout     time.Duration `yaml:"idle_timeout" validate:"required"`
    ShutdownTimeout time.Duration `yaml:"shutdown_timeout" validate:"required"`
    SwaggerDocs     bool          `yaml:"swagger_docs"`
    SwaggerFile     bool          `yaml:"swagger_file"`
}

type Config struct {
    App    AppConfig
    Logger sharedlogger.LoggerConfig
    DB     shareddb.DBConfig
    Redis  sharedredis.RedisConfig
    JWT    sharedjwt.JWTConfig
    GRPC   sharedgrpc.GRPCConfig
}
```

```go
// internal/shared/db/setup.go
type DBConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Host           string        `yaml:"host" validate:"required_unless=Standalone true"`
    Port           int           `yaml:"port" validate:"required_unless=Standalone true"`
    Name           string        `yaml:"name" validate:"required_unless=Standalone true"`
    User           string        `yaml:"user" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password" validate:"required_unless=Standalone true"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// internal/shared/redis/setup.go
type RedisConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Addr           string        `yaml:"addr" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password"`
    DB             int           `yaml:"db"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// internal/shared/jwt/jwt.go
type JWTConfig struct {
    AccessSecret  string        `yaml:"access_secret" validate:"required"`
    RefreshSecret string        `yaml:"refresh_secret" validate:"required"`
    AccessTTL     time.Duration `yaml:"access_ttl" validate:"required"`
    RefreshTTL    time.Duration `yaml:"refresh_ttl" validate:"required"`
}
```

```go
// internal/shared/logger/logger.go
type LoggerConfig struct {
    Format string `yaml:"format"` // "json" | "console"
    Level  string `yaml:"level"`  // "debug" | "info" | "warn" | "error"
}
```

```go
// internal/shared/grpc/setup.go
type GRPCConfig struct {
    Port int `yaml:"port" validate:"required"`
}
```

When `Standalone: true`, DB/Redis connections are skipped and their fields are not validated. This allows running commands like `cmd/swagger` without a running database.

### Loading order

- `APP_ENV` is read **only** from the OS environment variable
- Config files are YAML:
  1. `env/.env.yaml` — base values (always loaded)
  2. `env/.env.{APP_ENV}.yaml` — override (applied only if `APP_ENV` is set)
- Later values override earlier ones (YAML merge)

### Example YAML config

```yaml
# env/.env.yaml (base)
app:
  port: 8080
  read_timeout: 5s
  write_timeout: 10s
  idle_timeout: 120s
  shutdown_timeout: 10s

logger:
  format: console
  level: info

jwt:
  access_secret: change-me
  refresh_secret: change-me
  access_ttl: 15m
  refresh_ttl: 168h
```

```yaml
# env/.env.local.yaml (APP_ENV=local)
db:
  host: localhost
  port: 5432
  name: starter
  user: postgres
  password: postgres
  connect_timeout: 5s

redis:
  addr: localhost:6379
  password: ""
  db: 0
  connect_timeout: 5s
```

If `logger.level` is missing or invalid, the format default is used:
- `console` → `debug`
- `json` → `info`

---

## Wire — DI pattern

### Application level (`internal/initialize.go`)

```go
//go:build wireinject

package internal

func newApp(httpSrv *http.Server, cfg *config.Config, _ user.Module, _ *zap.Logger, _ *goredis.Client, grpcSrv *gogrpc.Server, api gohuma.API) *app.App {
    return app.New(httpSrv, cfg, grpcSrv, api)
}

func InitializeApp(ctx context.Context) (*app.App, error) {
    wire.Build(
        config.SetupConfig,
        logger.SetupLogger,
        wire.FieldsOf(new(*config.Config), "App", "Logger", "DB", "JWT", "Redis", "GRPC"),
        db.Setup,
        redis.Setup,
        server.SetupMux,
        server.SetupHTTPServer,
        huma.Setup,
        sharedgrpc.Setup,
        sharedjwt.NewJWTManager,
        middleware.Setup,

        user.InitializeUserModule,

        newApp,
    )
    return nil, nil
}
```

`newApp` is a thin Wire wrapper — it accepts unused dependencies (`_ user.Module`, `_ *zap.Logger`, `_ *goredis.Client`) to force Wire to create them (side-effect ordering), then delegates to `app.New` with only the needed parameters.

`wire.FieldsOf` extracts fields from `*Config` and exposes them as individual providers.

`db.Setup`, `redis.Setup`, `sharedgrpc.Setup` accept `*zap.Logger` as a parameter to ensure Wire initializes the logger first.

`InitializeApp(ctx)` accepts a context — propagated to `db.Setup` and `redis.Setup` for connection timeouts.

### Subdomain level (`internal/user/initialize.go`)

```go
//go:build wireinject

package user

type module struct{} // Wire marker: all handlers have been set up

func initModule(_ *auth.Handler, _ *usercontract.Contract) module {
    return module{}
}

func InitializeUserModule(db *bun.DB, api huma.API, grpcSrv *gogrpc.Server, jwtCfg sharedjwt.JWTConfig) (module, error) {
    wire.Build(
        sharedjwt.NewJWTManager,
        persistence.NewUserRepository,
        service.NewAuthService,
        auth.SetupHandler,
        usercontract.SetupContract,
        initModule,
    )
    return module{}, nil
}
```

`initModule` is a Wire dependency sink — it ensures all handlers are created. `SetupHandler` and `SetupContract` register routes during construction.

### Code generation

```bash
make wire   # wire gen ./...
```

Two files are generated:
- `internal/user/wire_gen.go` — implementation of `InitializeUserModule`
- `internal/wire_gen.go` — implementation of `InitializeApp`

Both carry the `//go:build !wireinject` tag and **must not be edited manually**.

---

## pkg/jwt

Low-level JWT package. Has no dependency on `internal/`.

```go
// pkg/jwt/manager.go

type Config struct {
    AccessSecret  string
    RefreshSecret string
    AccessTTL     time.Duration
    RefreshTTL    time.Duration
}

type Claims struct {
    UserID string `json:"user_id"`
    jwt.RegisteredClaims
    // tokenType — unexported field, internal implementation detail
}

type Manager struct{ cfg Config }

func NewManager(cfg Config) *Manager

// Generation
func (m *Manager) GenerateAccessToken(userID string) (string, error)
func (m *Manager) GenerateRefreshToken(userID string) (string, error)

// Validation
func (m *Manager) ValidateAccessToken(tokenStr string) (*Claims, error)
func (m *Manager) ValidateRefreshToken(tokenStr string) (*Claims, error)
```

Internal details (`tokenType`, constants `accessToken`/`refreshToken`) are unexported.
The public API is limited to `Manager`, `Claims`, and their methods.

---

## pkg/logger

Thin wrapper over `go.uber.org/zap`.

```go
type Logger = zap.Logger  // type alias, not a new type

func SetupLogger(format, level string) *Logger
func NewNop() *Logger  // for tests
```

`format` behaviour:
- `"json"` → `zap.NewProductionConfig()` (default level: `info`)
- anything else → `zap.NewDevelopmentConfig()` with colour output (default level: `debug`)

`level` overrides the format default. An invalid value is silently ignored.

---

## Subdomain: user

### domain/model

```go
// internal/user/domain/model/user.go
package model

type Role string

const (
    RoleUser  Role = "user"
    RoleAdmin Role = "admin"
)

type User struct {
    ID           string
    Email        string
    PasswordHash string
    Role         Role
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type TokenPair struct {
    AccessToken  string
    RefreshToken string
}
```

### domain/repository

```go
// internal/user/domain/repository/user.go
package repository

type UserRepository interface {
    FindByID(ctx context.Context, id string) (*model.User, error)
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    Create(ctx context.Context, user *model.User) error
    Update(ctx context.Context, user *model.User) error
}
```

### app/service

```go
// internal/user/app/service/auth.go
package service

type AuthService struct {
    userRepo   repository.UserRepository
    jwtManager *jwt.Manager
}

func NewAuthService(userRepo repository.UserRepository, jwtManager *jwt.Manager) *AuthService
```

`Login(ctx, email, password)` flow:
1. `FindByEmail(ctx, email)` — check the user exists
2. `bcrypt.CompareHashAndPassword` — verify password
3. `issueTokenPair` — generate access + refresh tokens

All methods accept `context.Context` — propagated from transport layer through service to repository for request cancellation support.

### infra/persistence

```go
// internal/user/infra/persistence/user.go
package persistence

type userModel struct {            // unexported, bun ORM model
    bun.BaseModel `bun:"table:users"`
    ID           string `bun:"id,pk"`
    Email        string `bun:"email,unique,notnull"`
    PasswordHash string `bun:"password_hash,notnull"`
    Role         string `bun:"role,notnull,default:'user'"`
    CreatedAt    int64  `bun:"created_at,notnull"`
    UpdatedAt    int64  `bun:"updated_at,notnull"`
}

type userRepository struct{ db *bun.DB }  // unexported

func NewUserRepository(db *bun.DB) repository.UserRepository
```

### transport/handler/auth

```go
// handler.go
package auth

type Handler struct {
    as *service.AuthService
}

func SetupHandler(api huma.API, as *service.AuthService) *Handler

// login.go  — registerLogin(api), login(ctx, *loginInput) (*tokenOutput, error)
// refresh.go — registerRefresh(api), refresh(ctx, *refreshInput) (*tokenOutput, error)
// types.go  — tokenBody, tokenOutput
```

### transport/contract/user

```go
// contract.go
package user

type Contract struct {
    contract.UnimplementedUserContractServer
    repo repository.UserRepository
}

func SetupContract(grpcSrv *grpc.Server, repo repository.UserRepository) *Contract

// get_user.go — GetUser(ctx, *GetUserRequest) (*GetUserResponse, error)
```

Request / response shapes:
```
POST /api/v1/auth/login
  Body:     { "email": string, "password": string (minLength: 6) }
  Response: { "access_token": string, "refresh_token": string }

POST /api/v1/auth/refresh
  Body:     { "refresh_token": string }
  Response: { "access_token": string, "refresh_token": string }
```

---

## cmd/api/main.go

```go
func main() {
    ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
    defer stop()

    app, err := internal.InitializeApp(ctx)
    if err != nil {
        panic("failed to initialize app: " + err.Error())
    }

    if err := app.Run(ctx); err != nil {
        zap.L().Fatal("server error", zap.Error(err))
    }
}
```

`app.Run(ctx)` starts HTTP and gRPC servers via `errgroup` and blocks until context cancellation. On shutdown it gracefully stops both servers in parallel with a configurable timeout (`ShutdownTimeout`).

---

## docker-compose.yml

Starts two services, both with healthchecks:

| Service    | Image                | Port   | Volume          |
|------------|----------------------|--------|-----------------|
| `postgres` | `postgres:16-alpine` | `5432` | `postgres_data` |
| `redis`    | `redis:7-alpine`     | `6379` | `redis_data`    |

`DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_PORT` are read from the environment
(defaults: `starter`, `postgres`, `postgres`, `5432`).

---

## Commands

```bash
make local-run        # APP_ENV=local go run ./cmd/api/...
make build            # go build -o bin/api ./cmd/api/...
make wire             # wire gen ./...
make swagger          # APP_ENV=standalone go run ./cmd/swagger/...
make proto            # generate Go code from .proto files
make lint             # golangci-lint run ./...
make docker-up        # docker-compose up -d
make docker-down      # docker-compose down
make test-unit        # unit tests only
make test-integration # integration tests (requires Docker)
make test-functional  # functional E2E tests (requires Docker)
make test             # run all: unit, integration, functional

# Migrations (require APP_ENV with DB config, e.g. APP_ENV=local)
make migrate          # apply pending migrations
make migrate-init     # create bun_migrations / bun_migration_locks tables
make migrate-rollback # rollback last migration group
make migrate-status   # show migration status
make migrate-create name=<name>  # create new .up.sql / .down.sql files
```

---

## Testing

### Build tags

All test files have a build tag — `//go:build unit` or `//go:build integration`. This means `go test ./...` without an explicit `-tags` flag runs **no tests**. Use the Makefile targets below.

### Strategy

| Layer                        | Approach                               | Build tag     | Docker |
|------------------------------|----------------------------------------|---------------|--------|
| `app/service`, `app/usecase` | Unit tests with mocks                  | `unit`        | No     |
| `infra/persistence`          | Integration tests with real PostgreSQL | `integration` | Yes    |
| `tests/functional`           | E2E tests with full HTTP server        | `functional`  | Yes    |

### Unit tests

Unit tests use `testify/mock` for repository and service mocks. No external dependencies required.

```bash
make test-unit
# go test ./... -tags=unit -v -count=1
```

### Integration tests

Repository tests use `testcontainers-go` to spin up a `postgres:16-alpine` container. `TestMain` applies migrations from `migrations/*.up.sql` and creates a `bun.DB`. Each test truncates tables via `TRUNCATE` for isolation.

```bash
make test-integration
# go test ./... -tags=integration -v -count=1
```

### Functional tests

Functional (E2E) tests spin up a full HTTP server with `httptest`, a PostgreSQL container via `testcontainers-go`, and load fixture data via `go-testfixtures`. They send real HTTP requests to all API endpoints.

```bash
make test-functional
# go test ./tests/functional/... -tags=functional -v -count=1
```

### Run all tests

```bash
make test
# runs test-unit, then test-integration, then test-functional sequentially
```

### Flags

| Flag       | Purpose                                                    |
|------------|------------------------------------------------------------|
| `-tags=`   | Select test group (`unit`, `integration`, or `functional`) |
| `-v`       | Verbose — show each test name and result                   |
| `-count=1` | Disable test caching — always run tests, never use cache   |

---

## Migrations

Database migrations use `bun/migrate` with embedded SQL files.

### Architecture

```
migrations/
├── embed.go                                 # //go:embed *.sql → var Migrations
├── 20250221000001_create_users.up.sql       # CREATE TABLE users
├── 20250221000001_create_users.down.sql     # DROP TABLE users
├── 20250221000002_add_role_to_users.up.sql  # ALTER TABLE ADD COLUMN role
└── 20250221000002_add_role_to_users.down.sql

internal/shared/migrate/
└── runner.go                             # Runner wraps bun/migrate.Migrator

cmd/migrate/
└── main.go                               # CLI: init, migrate, rollback, status, create
```

`cmd/migrate` is a standalone binary — it initializes only config, logger, and DB (no Wire, no Fiber/gRPC/Redis).

### Usage

First run requires table initialization:
```bash
APP_ENV=local make migrate-init
APP_ENV=local make migrate
```

Creating a new migration:
```bash
APP_ENV=local make migrate-create name=add_posts
# creates migrations/{timestamp}_add_posts.up.sql
# creates migrations/{timestamp}_add_posts.down.sql
```

SQL files in `migrations/` are embedded into the binary via `//go:embed` at compile time.

---

## gRPC

gRPC используется для межсервисного взаимодействия. `.proto` файлы — единственный источник правды для API-контрактов. Из них генерируются Go-клиенты и серверные стабы.

### Структура

```
proto/{subdomain}/{subdomain}.proto   →   gen/{subdomain}/*.pb.go
```

- `proto/` — исходные `.proto` определения, группируются по субдоменам
- `gen/` — сгенерированный код (`make proto`), **не редактировать вручную**

### Правила именования

| Элемент          | Формат                                                  | Пример                                         |
|------------------|---------------------------------------------------------|------------------------------------------------|
| proto package    | `{subdomain}`                                           | `package user;`                                |
| go_package       | `"starter-boilerplate/gen/{subdomain};{subdomain}"`     | `"starter-boilerplate/gen/user;user"`          |
| service          | `{Subdomain}Contract`                                   | `service UserContract`                         |
| rpc              | `{Verb}{Entity}`                                        | `rpc GetUser`                                  |
| request message  | `{RpcName}Request`                                      | `message GetUserRequest`                       |
| response message | `{RpcName}Response`                                     | `message GetUserResponse`                      |

### Добавление нового gRPC сервиса

1. Создать `proto/{name}/{name}.proto`
2. Запустить `make proto` — стабы появятся в `gen/{name}/`
3. Реализовать сгенерированный интерфейс `{Name}ContractServer` в субдомене

---

## Adding a new subdomain

1. Create `internal/{name}/`
2. Mirror the `user` subdomain structure:
   ```
   internal/{name}/
   ├── domain/
   │   ├── model/          # package model — entities
   │   └── repository/     # package repository — interfaces
   ├── app/
   │   └── service/        # package service — business logic
   ├── transport/
   │   ├── handler/{xxx}/  # package {xxx} — HTTP handlers (one package per handler group)
   │   └── contract/{xxx}/ # package {xxx} — gRPC contracts
   ├── infra/
   │   └── persistence/    # package persistence — repository implementation
   ├── initialize.go       # //go:build wireinject — InitializeXxxModule
   └── wire_gen.go         # generated
   ```
3. Declare `InitializeXxxModule` in `internal/{name}/initialize.go` with the required parameters
4. Add `{name}.InitializeXxxModule` to `wire.Build` in `internal/initialize.go`
5. Add `_ {name}.Module` parameter to `newApp` to guarantee initialization
6. Run `make wire`
