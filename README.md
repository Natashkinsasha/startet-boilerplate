# starter-boilerplate

Go starter project for bootstrapping new services.

---

## Stack

| Component      | Library                               |
|----------------|---------------------------------------|
| HTTP server    | `net/http` (stdlib)                   |
| OpenAPI / REST | `github.com/danielgtaylor/huma/v2`    |
| ORM            | `github.com/uptrace/bun` (PostgreSQL) |
| Cache          | `github.com/redis/go-redis/v9`        |
| Message broker | `github.com/rabbitmq/amqp091-go` (RabbitMQ) |
| Realtime       | `github.com/centrifugal/centrifuge`   |
| Configuration  | `gopkg.in/yaml.v3`                    |
| Migrations     | `bun/migrate`                         |
| Logging        | `log/slog` (stdlib)                   |
| Authentication | `github.com/golang-jwt/jwt/v5`        |
| gRPC           | `google.golang.org/grpc` + `protobuf` |
| DI             | `github.com/google/wire`              |
| Testing        | `github.com/testcontainers/testcontainers-go` |
| Infrastructure | Docker + docker-compose               |

---

## Project layout

```
starter-boilerplate/
├── cmd/
│   ├── api/
│   │   └── main.go              # entry point: signal → InitializeApp → app.Run
│   ├── migrate/
│   │   └── main.go              # DB migration CLI (init, migrate, rollback, status, create)
│   └── swagger/
│       └── main.go              # OpenAPI spec generation
│
├── internal/
│   ├── initialize.go        # Wire injector (//go:build wireinject)
│   ├── wire_gen.go          # generated by: wire gen ./...
│   ├── shared/              # project-specific glue (depends on config, internal/, or pkg/)
│   │   ├── app/
│   │   │   └── app.go       # App struct, New(), Run(), shutdown()
│   │   ├── config/
│   │   │   └── setup.go     # SetupConfig() → *Config; assembles Config from pkg/ types
│   │   ├── errs/
│   │   │   └── errs.go      # project-specific sentinel errors (uses pkg/apperror.New)
│   │   ├── server/
│   │   │   ├── setup.go     # SetupMux() → *http.ServeMux; SetupHTTPServer() → *http.Server
│   │   │   └── wire.go      # ProviderSet
│   │   ├── centrifugenode/
│   │   │   ├── publisher.go # NewPublisher — publishes to Centrifuge channels
│   │   │   ├── setup.go     # Setup(node, mux, jwtManager) → Init
│   │   │   └── wire.go      # ProviderSet
│   │   ├── huma/
│   │   │   ├── setup.go     # Setup(*http.ServeMux, AppConfig) → huma.API; error sanitization
│   │   │   └── spec.go      # GenerateSpecFile(huma.API) — writes docs/swagger.json
│   │   ├── middleware/
│   │   │   ├── setup.go     # Setup(*http.Server, huma.API, *jwt.Manager) → Init
│   │   │   ├── auth.go      # NewAuthMiddleware, AuthCtx (claims with sync.Once)
│   │   │   ├── role.go      # NewRoleMiddleware — role-based access control
│   │   │   ├── limiter.go   # NewLimiterMiddleware — per-IP rate limiting
│   │   │   ├── logger.go    # newLoggerMiddleware — request logging
│   │   │   └── requestid.go # NewRequestIDMiddleware — X-Request-ID header
│   │   ├── consumer/
│   │   │   └── setup.go     # Setup(conn, amqpConfig) → *pkgamqp.Broker
│   │   ├── logger/
│   │   │   └── logger.go    # LoggerConfig; SetupLogger(LoggerConfig) → *slog.Logger
│   │   └── jwt/
│   │       └── jwt.go       # JWTConfig; NewJWTManager(JWTConfig) → *pkgjwt.Manager
│   │
│   └── user/                # subdomain (user + auth + profile)
│       ├── domain/
│       │   ├── model/
│       │   │   ├── user.go            # User, TokenPair, Role
│       │   │   ├── profile.go         # Profile (Numbers, Strings JSONB maps)
│       │   │   └── profile_update.go  # ProfileUpdate builder (SetNumber, IncrNumber, SetString)
│       │   ├── repository/
│       │   │   ├── user.go            # UserRepository (interface)
│       │   │   └── profile.go         # ProfileRepository (interface)
│       │   └── event/
│       │       ├── user_created.go      # UserCreatedEvent (tag: profile)
│       │       ├── user_logged_in.go    # UserLoggedInEvent
│       │       └── password_changed.go  # PasswordChangedEvent (tag: profile)
│       ├── app/
│       │   ├── service/
│       │   │   ├── user.go          # UserService interface + impl
│       │   │   ├── token.go         # TokenService interface + impl
│       │   │   └── profile.go       # ProfileService — event handlers for profile updates
│       │   └── usecase/
│       │       ├── login.go           # LoginUseCase
│       │       ├── refresh.go         # RefreshUseCase
│       │       ├── register.go        # RegisterUseCase (publishes UserCreatedEvent)
│       │       ├── get_user.go        # GetUserUseCase
│       │       └── change_password.go # ChangePasswordUseCase (publishes PasswordChangedEvent)
│       ├── transport/
│       │   ├── dto/
│       │   │   └── user.go          # UserDTO, TokenPairDTO — shared across HTTP & gRPC
│       │   ├── handler/
│       │   │   ├── setup.go           # SetupHandlers() — registers all HTTP routes
│       │   │   ├── login.go           # LoginHandler (POST /api/v1/auth/login)
│       │   │   ├── refresh.go         # RefreshHandler (POST /api/v1/auth/refresh)
│       │   │   ├── register.go        # RegisterHandler (POST /api/v1/auth/register)
│       │   │   ├── change_password.go # ChangePasswordHandler (PUT /api/v1/auth/password)
│       │   │   ├── get_user.go        # GetUserHandler (GET /api/v1/users/{id})
│       │   │   └── types.go           # tokenOutput
│       │   ├── consumer/
│       │   │   ├── setup.go              # SetupConsumers() — registers all AMQP consumers
│       │   │   ├── profile_updater.go    # ProfileUpdaterConsumer — AMQP wiring, delegates to ProfileService
│       │   │   └── centrifuge_bridge.go  # BridgeConsumer — forwards events to Centrifuge channels
│       │   └── contract/
│       │       └── user.go          # gRPC Contract, SetupUserContract(), GetUser()
│       ├── infra/
│       │   └── persistence/
│       │       ├── user.go          # userRepository — implements UserRepository
│       │       └── profile.go       # profileRepository — implements ProfileRepository (JSONB updates)
│       ├── initialize.go            # Wire injector: Module, InitializeUserModule
│       └── wire_gen.go              # generated
│
├── pkg/                     # reusable code, no dependency on internal/
│   ├── amqp/
│   │   ├── config.go        # AMQPConfig struct
│   │   ├── setup.go         # Setup(AMQPConfig, *slog.Logger) → *amqp091.Connection
│   │   ├── publisher.go     # Publisher — publish raw bytes or JSON with validation
│   │   └── consumer.go      # Consumer, ConsumerConfig, TypedHandler[T] — reusable consumer
│   ├── apperror/
│   │   └── error.go         # AppError type, New(), Wrap() — generic error with HTTP status
│   ├── centrifuge/
│   │   └── setup.go         # Config; Setup(Config, *goredis.Client, *slog.Logger) → *centrifuge.Node
│   ├── db/
│   │   ├── setup.go         # DBConfig; Setup(DBConfig, *slog.Logger) → *bun.DB
│   │   ├── tx_context.go    # WithTx, TxFromCtx, Conn — tx-in-context pattern
│   │   ├── uow.go           # UoW interface, UnitOfWork — transactional execution
│   │   └── wire.go          # ProviderSet
│   ├── event/
│   │   ├── bus.go           # Event interface, Bus interface — domain event abstractions
│   │   ├── amqp.go          # AMQPBus — Bus implementation backed by pkg/amqp
│   │   └── wire.go          # ProviderSet + NewDefaultOutboxPublisher
│   ├── grpc/
│   │   ├── setup.go         # GRPCConfig; Setup(GRPCConfig, *slog.Logger) → *grpc.Server
│   │   └── error_interceptor.go # ErrorInterceptor — converts AppError → gRPC status
│   ├── jwt/
│   │   └── manager.go       # Manager, Claims, Config; token generation and validation
│   ├── logger/
│   │   └── setup.go         # Logger; SetupLogger(format, level, stacktraceLevel); NewNop()
│   ├── migrate/
│   │   └── runner.go        # Runner; wraps bun/migrate.Migrator
│   ├── outbox/
│   │   ├── model.go         # Entry — outbox table row
│   │   ├── bus.go           # OutboxBus — Bus impl that inserts into outbox table
│   │   ├── repository.go    # Repository — CRUD for outbox entries
│   │   ├── relay.go         # Relay — polls outbox and publishes via Publisher
│   │   └── wire.go          # ProviderSet
│   ├── redis/
│   │   └── setup.go         # RedisConfig; Setup(RedisConfig, *slog.Logger) → *goredis.Client
│   └── testcontainer/
│       ├── setup.go          # TestMain-level setup helpers
│       ├── container.go      # Container interface
│       ├── container_manager.go # ContainerManager — lifecycle management
│       ├── pg_container.go   # PostgreSQL testcontainer
│       ├── redis_container.go # Redis testcontainer
│       └── amqp_container.go  # RabbitMQ testcontainer
│
├── proto/                   # Protobuf definitions (.proto files)
├── gen/                     # generated code from proto (DO NOT edit)
├── migrations/              # SQL migrations (bun/migrate)
│   ├── embed.go             # //go:embed *.sql → var Migrations
│   └── *.sql                # {timestamp}_{name}.up.sql / .down.sql
├── tests/
│   ├── functional/
│   │   ├── api_test.go      # E2E tests — API endpoints
│   │   ├── auth_test.go     # E2E tests — auth flow
│   │   ├── user_test.go     # E2E tests — user endpoints
│   │   └── testdata/fixtures/
│   │       ├── users.yml     # user fixture data
│   │       └── outbox.yml    # empty — ensures outbox table is truncated between tests
│   └── suite/
│       └── functional_suite.go  # shared test suite setup
├── env/
│   ├── .env.yaml            # base values
│   ├── .env.{APP_ENV}.yaml  # environment override (loaded if APP_ENV is set)
│   ├── .env.standalone.yaml # standalone mode (DB/Redis disabled)
│   └── .env.test.yaml       # test environment config
├── docker-compose.yml
├── Makefile
└── go.mod                   # module: starter-boilerplate
```

---

## Architectural rules

### Subdomain layers

```
transport/handler   →  app/usecase  →  app/service  ←  infra/persistence
transport/consumer  →  app/service                   ←  infra/persistence
        ↓                  ↓               ↓                   ↓
   domain/repository  (interfaces)    domain/model (entities)
                                      domain/event (events)
```

| Layer             | Package                | Depends on                                         |
|-------------------|------------------------|----------------------------------------------------|
| Entities / VOs    | `domain/model`         | nothing external                                   |
| Interfaces        | `domain/repository`    | `domain/model`                                     |
| Domain events     | `domain/event`         | `pkg/event` (for `Event` interface)                |
| Services          | `app/service`          | `domain/repository`, `domain/model`, `domain/event`, `pkg/jwt`, `pkg/amqp`, `shared/errs` |
| Use cases         | `app/usecase`          | `app/service`, `domain/model`, `domain/event`, `shared/middleware`, `shared/errs`, `pkg/event` |
| Transport DTOs    | `transport/dto`        | `domain/model`                                     |
| HTTP handlers     | `transport/handler`    | `app/usecase`, `transport/dto`                     |
| AMQP consumers    | `transport/consumer`   | `app/service`, `shared/event`, `pkg/amqp`          |
| gRPC contracts    | `transport/contract`   | `domain/repository`, `transport/dto`               |
| Repository impl   | `infra/persistence`    | `domain/repository`, `domain/model`, `bun`         |

### Use cases vs services

**Use cases** (`app/usecase/`) orchestrate a user-initiated action. Each use case is a single-purpose struct with an `Execute` method. They are called from HTTP handlers.

**Services** (`app/service/`) come in two flavors:
- **Domain services** — interface + unexported impl (e.g. `UserService`, `TokenService`). Provide reusable operations called by use cases.
- **Event-handling services** — exported struct with `On*` methods (e.g. `ProfileService`). React to domain events from AMQP consumers. Methods match the `sharedevent.Route` signature: `func(ctx context.Context, event T, meta pkgamqp.DeliveryMeta) error`.

Event handlers are NOT use cases — they go in services.

### Consumers

Consumers are **thin AMQP wiring layers**. They only configure queue/exchange bindings and delegate to service method references via `sharedevent.Route`. No business logic in consumers.

```go
// consumer wires service methods directly — no wrapper per event
func (c *ProfileUpdaterConsumer) Register(b *pkgamqp.Broker) {
    r := sharedevent.NewRouter()
    sharedevent.Route(r, c.profileSvc.OnUserCreated)
    sharedevent.Route(r, c.profileSvc.OnPasswordChanged)
    // ...
}
```

Adding a new event handler = one new method on the service + one `sharedevent.Route` line in the consumer.

### Domain events

Events live in `domain/event/` and implement `pkg/event.Event` (requires `EventName() string`). Events optionally implement `event.Taggable` (`Tags() []string`) for headers-exchange routing.

Use cases publish events via `outbox.Bus`, which inserts them into the outbox table within the current transaction. The `outbox.Relay` polls unpublished entries and forwards them to AMQP. Consumers receive and route them via `shared/event.Router`.

### Concurrency: JSONB updates

Profile data uses JSONB columns (`numbers`, `strings`). All mutations go through the `ProfileUpdate` builder, which generates per-key `jsonb_set` SQL expressions:

- **`SetNumber`/`SetString`** → `jsonb_set(col, '{key}', to_jsonb(value))` — per-key overwrite
- **`IncrNumber`** → `jsonb_set(col, '{key}', to_jsonb(COALESCE((col->>'key')::numeric, 0) + delta))` — atomic increment

`Upsert` is `INSERT ... ON CONFLICT DO NOTHING` (create only). Never use full-column replacement for existing rows — it would overwrite concurrent changes.

### Package naming

Each package is named after its directory — no aliases needed:

```
internal/user/domain/model/            → package model
internal/user/domain/repository/       → package repository
internal/user/app/service/             → package service
internal/user/app/usecase/             → package usecase
internal/user/transport/dto/           → package dto
internal/user/transport/handler/       → package handler
internal/user/transport/contract/      → package contract
internal/user/infra/persistence/       → package persistence
```

```go
import (
    "starter-boilerplate/internal/user/domain/model"
    "starter-boilerplate/internal/user/domain/repository"
    "starter-boilerplate/internal/user/app/service"
    "starter-boilerplate/internal/user/app/usecase"
    "starter-boilerplate/internal/user/infra/persistence"
)
```

### Function naming

| Prefix               | Purpose                                          | Returns error     |
|----------------------|--------------------------------------------------|-------------------|
| `New...`             | Pure constructor, only creates an object         | yes, if needed    |
| `Setup...`           | Creates object + invokes methods (side effects)  | **no — panic**    |
| `Initialize...Module`| Wire injector — wires subdomain dependencies     | no                |

**`Setup*` never returns an error** — on critical failure it calls `panic`.

### Visibility (exported / unexported)

Repository implementations in `infra/` are **unexported**:
```go
type userRepository struct{ db *bun.DB }  // infra/persistence
```

Service implementations are **unexported**, interfaces are **exported**:
```go
type UserService interface { ... }     // exported interface
type userService struct{ ... }         // unexported implementation
```

Constructors (`New...`) are **exported** — required by Wire.

Internal helpers and types are **unexported**:
```go
func (d DBConfig) dsn() string { ... }  // used only inside db/setup.go
type tokenType string                    // used only inside pkg/jwt
```

### Handlers

Each handler is a separate struct in the `transport/handler/` package.
One file = one endpoint (input type, handler struct, registration, handler method).

`SetupHandlers(api, ...)` accepts all handlers and registers their routes:
```go
// setup.go
func SetupHandlers(api huma.API, loginH *LoginHandler, refreshH *RefreshHandler, getUserH *GetUserHandler) HandlersInit {
    loginH.Register(api)
    refreshH.Register(api)
    getUserH.Register(api)
    return HandlersInit{}
}

// login.go
type LoginHandler struct {
    loginUC *usecase.LoginUseCase
}

func NewLoginHandler(loginUC *usecase.LoginUseCase) *LoginHandler

func (h *LoginHandler) Register(api huma.API) {
    huma.Register(api, huma.Operation{...}, h.handle)
}

func (h *LoginHandler) handle(ctx context.Context, input *loginInput) (*tokenOutput, error) { ... }
```
Handler methods (`handle`) are **unexported**. Each handler has an exported `Register` method.

---

## Configuration

### Principle: config lives next to its tool

Each infrastructure package defines its **own** config type. `config/setup.go` reads YAML files and assembles the root `*Config`.

```
pkg/db/setup.go                  → type DBConfig struct
pkg/redis/setup.go               → type RedisConfig struct
pkg/amqp/config.go               → type AMQPConfig struct
pkg/grpc/setup.go                → type GRPCConfig struct
pkg/outbox/relay.go              → type RelayConfig struct
pkg/centrifuge/setup.go          → type Config struct
internal/shared/jwt/jwt.go       → type JWTConfig struct
internal/shared/logger/logger.go → type LoggerConfig struct
internal/shared/config/setup.go  → type Config struct  (aggregates all)
```

Dependency direction:
```
config  →  pkg/db, pkg/redis, pkg/amqp, pkg/grpc, shared/jwt, shared/logger
```

### Structs

```go
// internal/shared/config/setup.go
type AppConfig struct {
    Port            int           `yaml:"port" validate:"required"`
    ReadTimeout     time.Duration `yaml:"read_timeout" validate:"required"`
    WriteTimeout    time.Duration `yaml:"write_timeout" validate:"required"`
    IdleTimeout     time.Duration `yaml:"idle_timeout" validate:"required"`
    ShutdownTimeout time.Duration `yaml:"shutdown_timeout" validate:"required"`
    SwaggerDocs     bool          `yaml:"swagger_docs"`
    SwaggerFile     bool          `yaml:"swagger_file"`
}

type Config struct {
    App        AppConfig
    Logger     sharedlogger.LoggerConfig
    DB         pkgdb.DBConfig
    Redis      pkgredis.RedisConfig
    JWT        sharedjwt.JWTConfig
    GRPC       pkggrpc.GRPCConfig
    AMQP       pkgamqp.AMQPConfig
    Outbox     outbox.RelayConfig
    Centrifuge pkgcentrifuge.Config
}
```

```go
// pkg/db/setup.go
type DBConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Host           string        `yaml:"host" validate:"required_unless=Standalone true"`
    Port           int           `yaml:"port" validate:"required_unless=Standalone true"`
    Name           string        `yaml:"name" validate:"required_unless=Standalone true"`
    User           string        `yaml:"user" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password" validate:"required_unless=Standalone true"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// pkg/redis/setup.go
type RedisConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Addr           string        `yaml:"addr" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password"`
    DB             int           `yaml:"db"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// pkg/amqp/config.go
type AMQPConfig struct {
    Standalone bool   `yaml:"standalone"`
    URL        string `yaml:"url" validate:"required_unless=Standalone true"`
}
```

```go
// internal/shared/jwt/jwt.go
type JWTConfig struct {
    AccessSecret  string        `yaml:"access_secret" validate:"required"`
    RefreshSecret string        `yaml:"refresh_secret" validate:"required"`
    AccessTTL     time.Duration `yaml:"access_ttl" validate:"required"`
    RefreshTTL    time.Duration `yaml:"refresh_ttl" validate:"required"`
}
```

```go
// internal/shared/logger/logger.go
type LoggerConfig struct {
    Format string `yaml:"format"` // "json" | "console"
    Level  string `yaml:"level"`  // "debug" | "info" | "warn" | "error"
}
```

```go
// pkg/grpc/setup.go
type GRPCConfig struct {
    Port int `yaml:"port" validate:"required"`
}
```

When `Standalone: true`, DB/Redis connections are skipped and their fields are not validated. This allows running commands like `cmd/swagger` without a running database.

### Loading order

- `APP_ENV` is read **only** from the OS environment variable
- Config files are YAML:
  1. `env/.env.yaml` — base values (always loaded)
  2. `env/.env.{APP_ENV}.yaml` — override (applied only if `APP_ENV` is set)
- Later values override earlier ones (YAML merge)

### Example YAML config

```yaml
# env/.env.yaml (base)
app:
  port: 8080
  read_timeout: 5s
  write_timeout: 10s
  idle_timeout: 120s
  shutdown_timeout: 10s

logger:
  format: console
  level: info

jwt:
  access_secret: change-me
  refresh_secret: change-me
  access_ttl: 15m
  refresh_ttl: 168h
```

```yaml
# env/.env.local.yaml (APP_ENV=local)
db:
  host: localhost
  port: 5432
  name: starter
  user: postgres
  password: postgres
  connect_timeout: 5s

redis:
  addr: localhost:6379
  password: ""
  db: 0
  connect_timeout: 5s
```

If `logger.level` is missing or invalid, the format default is used:
- `console` → `debug`
- `json` → `info`

---

## Wire — DI pattern

### ProviderSets

Each package exports a `ProviderSet` variable in `wire.go`, grouping its constructors and bindings:

```go
// pkg/db/wire.go
var ProviderSet = wire.NewSet(Setup, NewUnitOfWork, wire.Bind(new(UoW), new(*UnitOfWork)))

// pkg/outbox/wire.go
var ProviderSet = wire.NewSet(NewRepository, NewOutboxBus, wire.Bind(new(Bus), new(*OutboxBus)), NewRelay)

// pkg/event/wire.go
var ProviderSet = wire.NewSet(NewEventBus, NewDefaultOutboxPublisher, wire.Bind(new(outbox.Publisher), new(*OutboxPublisher)))

// internal/shared/server/wire.go
var ProviderSet = wire.NewSet(SetupMux, SetupHTTPServer)

// internal/shared/centrifugenode/wire.go
var ProviderSet = wire.NewSet(NewPublisher, Setup)
```

### Application level (`internal/initialize.go`)

```go
//go:build wireinject

package internal

func newApp(httpSrv *http.Server, cfg *config.Config, _ user.Module, _ middleware.Init,
    _ *slog.Logger, _ *goredis.Client, grpcSrv *gogrpc.Server, api gohuma.API,
    broker *pkgamqp.Broker, relay *outbox.Relay, centrifugeNode *gocentrifuge.Node,
    _ centrifugenode.Init) *app.App {
    return app.New(httpSrv, cfg, grpcSrv, api, broker, relay, centrifugeNode)
}

func InitializeApp(ctx context.Context) *app.App {
    wire.Build(
        config.SetupConfig,
        logger.SetupLogger,
        wire.FieldsOf(new(*config.Config), "App", "Logger", "DB", "JWT", "Redis", "GRPC", "AMQP", "Outbox", "Centrifuge"),

        pkgdb.ProviderSet,
        redis.Setup,
        pkgamqp.Setup,
        server.ProviderSet,
        huma.Setup,
        pkggrpc.Setup,
        sharedjwt.NewJWTManager,

        event.ProviderSet,
        outbox.ProviderSet,

        pkgcentrifuge.Setup,
        centrifugenode.ProviderSet,

        middleware.Setup,
        sharedconsumer.Setup,
        user.InitializeUserModule,

        newApp,
    )
    return nil
}
```

`newApp` is a thin Wire wrapper — it accepts unused dependencies (`_ user.Module`, `_ middleware.Init`, `_ *slog.Logger`, `_ *goredis.Client`, `_ centrifugenode.Init`) to force Wire to create them (side-effect ordering), then delegates to `app.New` with only the needed parameters.

`wire.FieldsOf` extracts fields from `*Config` and exposes them as individual providers.

`db.Setup`, `redis.Setup`, `pkgamqp.Setup`, `pkggrpc.Setup` accept `*slog.Logger` as a parameter to ensure Wire initializes the logger first.

`InitializeApp(ctx)` accepts a context — propagated to `db.Setup` and `redis.Setup` for connection timeouts.

### Subdomain level (`internal/user/initialize.go`)

```go
//go:build wireinject

package user

type Module struct{} // Wire marker: all handlers have been set up

func NewModule(_ handler.HandlersInit, _ usercontract.Init, _ consumer.Init, _ consumer.BridgeInit) Module {
    return Module{}
}

func InitializeUserModule(api huma.API, grpcSrv *gogrpc.Server, _ *pkgjwt.Manager,
    _ *bun.DB, _ outbox.Bus, _ *pkgamqp.Broker, _ pkgdb.UoW,
    _ *centrifugenode.Publisher, _ middleware.Init) Module {
    wire.Build(
        // persistence
        persistence.NewUserRepository,
        persistence.NewProfileRepository,
        // services
        service.NewUserService,
        service.NewTokenService,
        service.NewProfileService,
        // usecases
        usecase.NewLoginUseCase,
        usecase.NewRefreshUseCase,
        usecase.NewGetUserUseCase,
        usecase.NewRegisterUseCase,
        usecase.NewChangePasswordUseCase,
        // handlers
        handler.NewLoginHandler,
        handler.NewRefreshHandler,
        handler.NewGetUserHandler,
        handler.NewRegisterHandler,
        handler.NewChangePasswordHandler,
        handler.SetupHandlers,
        // grpc
        usercontract.SetupUserContract,
        // consumers
        consumer.NewProfileUpdaterConsumer,
        consumer.SetupConsumers,
        consumer.NewBridgeConsumer,
        consumer.SetupBridgeConsumer,

        NewModule,
    )
    return Module{}
}
```

`NewModule` is a Wire dependency sink — it ensures all handlers, contracts, and consumers are created.

Wire constructors are grouped by layer: **persistence → services → usecases → handlers → consumers**. This grouping is a convention — Wire resolves dependencies by type, not by order.

`InitializeUserModule` accepts `_ middleware.Init` to guarantee middleware is installed before handlers are registered (huma v2 captures middleware at handler registration time). Infrastructure dependencies (`outbox.Bus`, `*pkgamqp.Broker`, `pkgdb.UoW`, etc.) are accepted as parameters provided externally by the application-level injector.

### Code generation

```bash
make wire   # wire gen ./...
```

Two files are generated:
- `internal/user/wire_gen.go` — implementation of `InitializeUserModule`
- `internal/wire_gen.go` — implementation of `InitializeApp`

Both carry the `//go:build !wireinject` tag and **must not be edited manually**.

---

## pkg/jwt

Low-level JWT package. Has no dependency on `internal/`.

```go
// pkg/jwt/manager.go

type Config struct {
    AccessSecret  string
    RefreshSecret string
    AccessTTL     time.Duration
    RefreshTTL    time.Duration
}

type Claims struct {
    UserID    string    `json:"user_id"`
    Role      string    `json:"role"`
    TokenType tokenType `json:"token_type"` // unexported type — internal detail
    jwt.RegisteredClaims
}

type Manager struct{ cfg Config }

func NewManager(cfg Config) *Manager

// Generation
func (m *Manager) GenerateAccessToken(userID, role string) (string, error)
func (m *Manager) GenerateRefreshToken(userID, role string) (string, error)

// Validation
func (m *Manager) ValidateAccessToken(tokenStr string) (*Claims, error)
func (m *Manager) ValidateRefreshToken(tokenStr string) (*Claims, error)
```

Internal details (`tokenType`, constants `accessToken`/`refreshToken`) are unexported.
The public API is limited to `Manager`, `Claims`, `Config`, and their methods.

---

## pkg/logger

Thin wrapper over `log/slog` (stdlib).

```go
type Logger = slog.Logger  // type alias, not a new type

func SetupLogger(format, level string) *Logger
func NewNop() *Logger  // for tests
```

`format` behaviour:
- `"json"` → `slog.NewJSONHandler` (structured JSON to stdout)
- anything else → `slog.NewTextHandler` (human-readable to stdout)

`level` parsing:
- `"debug"` → `slog.LevelDebug`
- `"warn"` / `"warning"` → `slog.LevelWarn`
- `"error"` → `slog.LevelError`
- default → `slog.LevelInfo`

---

## Subdomain: user

### domain/model

```go
// internal/user/domain/model/user.go
package model

type Role string

const (
    RoleUser  Role = "user"
    RoleAdmin Role = "admin"
)

type User struct {
    ID           string
    Email        string
    PasswordHash string
    Role         Role
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type TokenPair struct {
    AccessToken  string
    RefreshToken string
}
```

### domain/model (continued)

```go
// internal/user/domain/model/profile.go
type Profile struct {
    UserID  string
    Numbers map[string]float64
    Strings map[string]string
}
```

```go
// internal/user/domain/model/profile_update.go
// Fluent builder for atomic JSONB updates (per-key jsonb_set).
type ProfileUpdate struct {
    NumberSets map[string]float64
    NumberIncr map[string]float64
    StringSets map[string]string
}

func NewProfileUpdate() *ProfileUpdate
func (u *ProfileUpdate) SetNumber(key string, val float64) *ProfileUpdate
func (u *ProfileUpdate) IncrNumber(key string, delta float64) *ProfileUpdate
func (u *ProfileUpdate) SetString(key string, val string) *ProfileUpdate
```

Usage:
```go
upd := model.NewProfileUpdate().
    IncrNumber("password_changes", 1).
    SetString("status", "active")
```

### domain/event

Events implement `pkg/event.Event` and optionally `event.Taggable` for headers-exchange routing:

```go
// internal/user/domain/event/user_created.go
const UserCreated = "user.created"

type UserCreatedEvent struct {
    UserID string `json:"user_id" validate:"required,uuid"`
    Email  string `json:"email"   validate:"required,email"`
}

func (UserCreatedEvent) EventName() string { return UserCreated }
func (UserCreatedEvent) Tags() []string    { return []string{"profile"} }
```

```go
// internal/user/domain/event/user_logged_in.go
const UserLoggedIn = "user.logged_in"

type UserLoggedInEvent struct {
    UserID    string `json:"user_id"    validate:"required,uuid"`
    IP        string `json:"ip"         validate:"required"`
    UserAgent string `json:"user_agent" validate:"required"`
}

func (UserLoggedInEvent) EventName() string { return UserLoggedIn }
```

```go
// internal/user/domain/event/password_changed.go
const PasswordChanged = "user.password_changed"

type PasswordChangedEvent struct {
    UserID string `json:"user_id" validate:"required,uuid"`
}

func (PasswordChangedEvent) EventName() string { return PasswordChanged }
func (PasswordChangedEvent) Tags() []string    { return []string{"profile"} }
```

### domain/repository

```go
// internal/user/domain/repository/user.go
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*model.User, error)
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    Create(ctx context.Context, user *model.User) error
    Update(ctx context.Context, user *model.User) error
}
```

```go
// internal/user/domain/repository/profile.go
type ProfileRepository interface {
    FindByUserID(ctx context.Context, userID string) (*model.Profile, error)
    Upsert(ctx context.Context, profile *model.Profile) error          // INSERT ... ON CONFLICT DO NOTHING
    Update(ctx context.Context, userID string, upd *model.ProfileUpdate) error  // per-key jsonb_set
}
```

### app/service

Domain services — interface + unexported impl:

```go
// internal/user/app/service/user.go
type UserService interface {
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    FindByID(ctx context.Context, id string) (*model.User, error)
    CheckPassword(passwordHash, password string) error
    Create(ctx context.Context, user *model.User) error
    HashPassword(password string) (string, error)
    UpdatePassword(ctx context.Context, id, hash string) error
}

func NewUserService(userRepo repository.UserRepository) UserService
```

```go
// internal/user/app/service/token.go
type TokenService interface {
    IssueTokenPair(userID, role string) (*model.TokenPair, error)
    ValidateRefreshToken(token string) (*jwt.Claims, error)
}

func NewTokenService(jwtManager *jwt.Manager) TokenService
```

Event-handling service — exported struct, methods match `sharedevent.Route` signature:

```go
// internal/user/app/service/profile.go
type ProfileService struct {
    profileRepo repository.ProfileRepository
}

func NewProfileService(pr repository.ProfileRepository) *ProfileService

func (s *ProfileService) OnUserCreated(ctx context.Context, evt domainevent.UserCreatedEvent, _ pkgamqp.DeliveryMeta) error
func (s *ProfileService) OnPasswordChanged(ctx context.Context, evt domainevent.PasswordChangedEvent, _ pkgamqp.DeliveryMeta) error
```

### app/usecase

Use cases orchestrate services. Each use case is a single-purpose struct with an `Execute` method.

```go
// internal/user/app/usecase/login.go
package usecase

type LoginUseCase struct {
    userService  service.UserService
    tokenService service.TokenService
    bus          outbox.Bus
}

func NewLoginUseCase(us service.UserService, ts service.TokenService, bus outbox.Bus) *LoginUseCase
```

`Execute(ctx, email, password, ip, userAgent)` flow:
1. `userService.FindByEmail(ctx, email)` — find user
2. `userService.CheckPassword(passwordHash, password)` — verify password via bcrypt
3. `bus.Publish(ctx, UserLoggedInEvent{...})` — publish login event via outbox
4. `tokenService.IssueTokenPair(userID, role)` — generate access + refresh tokens

```go
// internal/user/app/usecase/refresh.go
package usecase

type RefreshUseCase struct {
    userService  service.UserService
    tokenService service.TokenService
}

func NewRefreshUseCase(us service.UserService, ts service.TokenService) *RefreshUseCase
```

`Execute(ctx, refreshToken)` flow:
1. `tokenService.ValidateRefreshToken(refreshToken)` — validate and extract claims
2. `userService.FindByID(ctx, claims.UserID)` — verify user still exists
3. `tokenService.IssueTokenPair(userID, role)` — issue new token pair

```go
// internal/user/app/usecase/register.go
package usecase

type RegisterUseCase struct {
    userService  service.UserService
    tokenService service.TokenService
    bus          outbox.Bus
    uow          db.UoW
}

func NewRegisterUseCase(us service.UserService, ts service.TokenService, bus outbox.Bus, uow db.UoW) *RegisterUseCase
```

`Execute(ctx, email, password)` flow (wrapped in `uow.Do` transaction):
1. `userService.FindByEmail(ctx, email)` — check email uniqueness → `ErrEmailAlreadyExists`
2. `userService.HashPassword(password)` — hash via bcrypt
3. Create `model.User{ID: uuid.New(), Email, PasswordHash, Role: RoleUser}`
4. `userService.Create(ctx, user)` — persist user
5. `bus.Publish(ctx, UserCreatedEvent{...})` — insert domain event into outbox (same tx)
6. `tokenService.IssueTokenPair(userID, role)` — auto-login, return tokens

```go
// internal/user/app/usecase/get_user.go
package usecase

type GetUserUseCase struct {
    userService service.UserService
}

func NewGetUserUseCase(us service.UserService) *GetUserUseCase
```

`Execute(ctx middleware.AuthCtx, targetID)` flow:
1. `ctx.Claims()` — extract authenticated user claims
2. Role check: admins can access any user; non-admins can only access their own profile
3. `userService.FindByID(ctx, targetID)` — fetch user → `ErrNotFound` if missing

```go
// internal/user/app/usecase/change_password.go
package usecase

type ChangePasswordUseCase struct {
    userService service.UserService
    bus         outbox.Bus
    uow         db.UoW
}

func NewChangePasswordUseCase(us service.UserService, bus outbox.Bus, uow db.UoW) *ChangePasswordUseCase
```

`Execute(ctx middleware.AuthCtx, oldPassword, newPassword)` flow (wrapped in `uow.Do` transaction):
1. `ctx.Claims()` → get userID
2. `userService.FindByID(ctx, userID)` → load user → `ErrNotFound` if missing
3. `userService.CheckPassword(user.PasswordHash, oldPassword)` → verify old password → `ErrInvalidCredentials`
4. `userService.HashPassword(newPassword)` → hash new password
5. `userService.UpdatePassword(ctx, userID, hash)` → persist
6. `bus.Publish(ctx, PasswordChangedEvent{UserID})` → insert domain event into outbox (same tx)

### infra/persistence

```go
// internal/user/infra/persistence/user.go
type userModel struct {            // unexported, bun ORM model
    bun.BaseModel `bun:"table:users"`
    ID           string `bun:"id,pk"`
    Email        string `bun:"email,unique,notnull"`
    PasswordHash string `bun:"password_hash,notnull"`
    Role         string `bun:"role,notnull,default:'user'"`
    CreatedAt    int64  `bun:"created_at,notnull"`
    UpdatedAt    int64  `bun:"updated_at,notnull"`
}

type userRepository struct{}  // unexported, stateless — uses pkgdb.Conn(ctx) for queries
func NewUserRepository(db *bun.DB) repository.UserRepository
```

```go
// internal/user/infra/persistence/profile.go
type profileModel struct {
    bun.BaseModel `bun:"table:user_profiles"`
    UserID    string             `bun:"user_id,pk"`
    Numbers   map[string]float64 `bun:"numbers,type:jsonb,notnull,default:'{}'"`
    Strings   map[string]string  `bun:"strings,type:jsonb,notnull,default:'{}'"`
    CreatedAt int64              `bun:"created_at,notnull"`
    UpdatedAt int64              `bun:"updated_at,notnull"`
}

type profileRepository struct{ db *bun.DB }
func NewProfileRepository(db *bun.DB) repository.ProfileRepository
```

`Upsert` uses `INSERT ... ON CONFLICT (user_id) DO NOTHING` — create only.
`Update` builds per-key `jsonb_set` expressions from `ProfileUpdate`, ensuring concurrent modifications to different keys don't interfere.

### transport/dto

Stateless data-transfer package shared by HTTP handlers and gRPC contracts. Converts domain models to transport representations. Carries JSON tags so both layers can use the same types directly.

```go
// user.go
package dto

type UserDTO struct {
    ID    string `json:"id"`
    Email string `json:"email"`
    Role  string `json:"role"`
}

type TokenPairDTO struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
}

func NewUserDTO(u *model.User) UserDTO
func NewTokenPairDTO(tp *model.TokenPair) TokenPairDTO
```

### transport/handler

```go
// setup.go
package handler

type HandlersInit struct{}

func SetupHandlers(api huma.API, loginH *LoginHandler, refreshH *RefreshHandler,
    getUserH *GetUserHandler, registerH *RegisterHandler, changePasswordH *ChangePasswordHandler) HandlersInit

// login.go           — LoginHandler (POST /api/v1/auth/login)
// refresh.go         — RefreshHandler (POST /api/v1/auth/refresh)
// register.go        — RegisterHandler (POST /api/v1/auth/register)
// change_password.go — ChangePasswordHandler (PUT /api/v1/auth/password)
// get_user.go        — GetUserHandler (GET /api/v1/users/{id})
// types.go           — tokenOutput (uses dto.TokenPairDTO as Body)
```

### transport/consumer

Consumers are thin AMQP wiring — no business logic. They delegate directly to service method references:

```go
// internal/user/transport/consumer/profile_updater.go
type ProfileUpdaterConsumer struct {
    profileSvc *service.ProfileService
}

func NewProfileUpdaterConsumer(ps *service.ProfileService) *ProfileUpdaterConsumer

func (c *ProfileUpdaterConsumer) Register(b *pkgamqp.Broker) {
    r := sharedevent.NewRouter()
    sharedevent.Route(r, c.profileSvc.OnUserCreated)       // method reference — no wrapper
    sharedevent.Route(r, c.profileSvc.OnPasswordChanged)   // method reference — no wrapper
    r.Default(...)

    pkgamqp.AddRawConsumer(b, pkgamqp.ConsumerConfig{
        Queue:    "tag.profile",
        Exchange: event.ExchangeTagged,
        BindingArgs: amqp091.Table{"x-match": "any", "tag.profile": true},
    }, r.Handler())
}
```

### transport/contract

```go
// user.go
package contract

type Contract struct {
    gen.UnimplementedUserContractServer
    ur repository.UserRepository
}

type Init struct{}

func SetupUserContract(grpcSrv *grpc.Server, ur repository.UserRepository) Init

// GetUser(ctx, *gen.GetUserRequest) (*gen.GetUserResponse, error)
// Uses dto.NewUserDTO() then maps DTO → protobuf
```

### HTTP endpoints

```
POST /api/v1/auth/register
  Body:     { "email": string (format: email), "password": string (minLength: 6) }
  Response: { "access_token": string, "refresh_token": string }
  Notes:    Creates a new user with role "user", publishes UserCreatedEvent, returns tokens

POST /api/v1/auth/login
  Body:     { "email": string (format: email), "password": string (minLength: 6) }
  Response: { "access_token": string, "refresh_token": string }
  Notes:    Publishes UserLoggedInEvent via outbox

POST /api/v1/auth/refresh
  Body:     { "refresh_token": string }
  Response: { "access_token": string, "refresh_token": string }

PUT /api/v1/auth/password
  Headers:  Authorization: Bearer <access_token>
  Body:     { "old_password": string (minLength: 6), "new_password": string (minLength: 6) }
  Response: 204 No Content
  Notes:    Verifies old password, updates hash, publishes PasswordChangedEvent

GET /api/v1/users/{id}
  Headers:  Authorization: Bearer <access_token>
  Response: { "user": { "id": string, "email": string, "role": string } }
  Notes:    Admins can access any user; non-admins can only access their own profile
```

---

## Middleware

Middleware is installed in `internal/shared/middleware/setup.go` in two layers:

**Huma-level** (applied per-operation, outermost first):
1. `RequestID` — generates/propagates `X-Request-ID` header
2. `Logger` — logs request method, path, status, duration
3. `Limiter` — per-IP rate limiting (100 req/min)
4. `Auth` — validates Bearer token on endpoints with `bearerAuth` security
5. `Role` — checks `requiredRoles` metadata on operations

**HTTP-level** (wraps the entire `http.Handler`):
- `WithCORS` — permissive CORS headers
- `WithRecover` — panic recovery, returns 500 JSON

**Important**: `middleware.Setup` must run before handler registration because huma v2 captures middleware at the time `huma.Register` is called. This ordering is enforced via Wire: `InitializeUserModule` accepts `_ middleware.Init` as a parameter.

### Typed context: AuthCtx

Use cases that require authentication accept the `AuthCtx` interface instead of raw `context.Context`:

```go
// auth.go
type AuthCtx interface {
    context.Context
    Claims() *jwt.Claims   // lazy, memoized via sync.Once; panics if no claims
}

func NewAuthCtx(ctx context.Context) AuthCtx
```

This provides **compile-time safety**: a use case declares exactly what auth data it needs. `Claims()` is lazily evaluated with `sync.Once` — no extraction happens until the method is called.

Handlers create the context:
```go
h.uc.Execute(middleware.NewAuthCtx(ctx), ...)
```

---

## Error handling

### AppError

The generic error type lives in `pkg/apperror/error.go` (reusable across projects):

```go
type AppError struct {
    Status  int      // HTTP status code
    Message string   // user-facing message
}

func (e *AppError) GetStatus() int  // implements huma.StatusError
func (e *AppError) Error() string
func New(status int, message string) *AppError
func Wrap(err error, status int, message string) *AppError
```

`AppError` implements huma's `StatusError` interface (`GetStatus() int`), so huma automatically uses the correct HTTP status code when a handler returns an `AppError`.

### Sentinel errors

Project-specific sentinel errors live in `internal/shared/errs/errs.go`:

```go
var (
    ErrAccessDenied       = apperror.New(http.StatusForbidden, "access denied")
    ErrNotFound           = apperror.New(http.StatusNotFound, "not found")
    ErrInvalidCredentials = apperror.New(http.StatusUnauthorized, "invalid credentials")
    ErrInvalidToken       = apperror.New(http.StatusUnauthorized, "invalid token")
    ErrEmailAlreadyExists = apperror.New(http.StatusConflict, "email already exists")
)
```

This separation allows `pkg/apperror` to be reused in other projects while sentinel errors remain project-specific.

### HTTP error sanitization

`huma.NewErrorWithContext` is overridden in `internal/shared/huma/setup.go` to sanitize 5xx errors — internal details are logged and the response is replaced with a generic `"internal server error"` message.

### gRPC error interceptor

`pkg/grpc/error_interceptor.go` provides a `grpc.UnaryServerInterceptor` that converts `AppError` to gRPC status codes via `httpToGRPC()` mapping:

| HTTP status             | gRPC code              |
|-------------------------|------------------------|
| 400 Bad Request         | `InvalidArgument`      |
| 401 Unauthorized        | `Unauthenticated`      |
| 403 Forbidden           | `PermissionDenied`     |
| 404 Not Found           | `NotFound`             |
| 409 Conflict            | `AlreadyExists`        |
| 422 Unprocessable       | `InvalidArgument`      |
| 429 Too Many Requests   | `ResourceExhausted`    |
| other                   | `Internal`             |

Unknown errors are logged and returned as `codes.Internal` with a sanitized message.

---

## cmd/api/main.go

```go
func main() {
    ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
    defer stop()

    app := internal.InitializeApp(ctx)

    if err := app.Run(ctx); err != nil {
        slog.Error("server error", slog.Any("error", err))
        os.Exit(1)
    }
}
```

`app.Run(ctx)` starts HTTP, gRPC servers, AMQP consumers, outbox relay, and Centrifuge node via `errgroup` and blocks until context cancellation. On shutdown it gracefully stops all components with a configurable timeout (`ShutdownTimeout`).

---

## Outbox pattern

Domain events are published reliably using the transactional outbox pattern (`pkg/outbox/`):

1. **Use case** calls `bus.Publish(ctx, event)` inside a database transaction
2. **`OutboxBus`** serializes the event and inserts an `Entry` row into the `outbox` table (same tx)
3. **`Relay`** polls the outbox table on a configurable interval, fetches unpublished entries with `SELECT ... FOR UPDATE SKIP LOCKED`, publishes them to AMQP, and marks them as published — all within a single transaction
4. If publishing fails, the relay stops at the first failure to preserve FIFO ordering

```go
// pkg/outbox/relay.go
type RelayConfig struct {
    PollInterval time.Duration `yaml:"poll_interval"` // default: 1s
    BatchSize    int           `yaml:"batch_size"`    // default: 100
}
```

The `outbox.Publisher` interface decouples the relay from the transport. The default implementation (`event.OutboxPublisher`) publishes to AMQP via `pkg/event`.

---

## docker-compose.yml

Starts three services, all with healthchecks:

| Service    | Image                          | Port          | Volume          |
|------------|--------------------------------|---------------|-----------------|
| `postgres` | `postgres:16-alpine`           | `5432`        | `postgres_data` |
| `redis`    | `redis:7-alpine`               | `6379`        | `redis_data`    |
| `rabbitmq` | `rabbitmq:3-management-alpine` | `5672`,`15672`| `rabbitmq_data` |

`DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_PORT` are read from the environment
(defaults: `starter`, `postgres`, `postgres`, `5432`).

---

## Commands

```bash
make local-run        # APP_ENV=local go run ./cmd/api/...
make dev              # air (live reload)
make build            # go build -o bin/api ./cmd/api/...
make wire             # wire gen ./...
make swagger          # APP_ENV=standalone go run ./cmd/swagger/...
make proto            # generate Go code from .proto files
make lint             # golangci-lint run ./...
make vet              # go vet with all build tags
make deps             # go mod tidy
make install-tools    # install wire, protoc-gen-go, golangci-lint, air
make docker-up        # docker-compose up -d
make docker-down      # docker-compose down
make test-unit        # unit tests only
make test-integration # integration tests (requires Docker)
make test-functional  # functional E2E tests (requires Docker)
make test             # run all: unit, integration, functional

# Migrations (require APP_ENV with DB config, e.g. APP_ENV=local)
make migrate          # apply pending migrations
make migrate-init     # create bun_migrations / bun_migration_locks tables
make migrate-rollback # rollback last migration group
make migrate-status   # show migration status
make migrate-create name=<name>  # create new .up.sql / .down.sql files
```

---

## Testing

### Build tags

All test files have a build tag — `//go:build unit` or `//go:build integration`. This means `go test ./...` without an explicit `-tags` flag runs **no tests**. Use the Makefile targets below.

### Strategy

| Layer                        | Approach                               | Build tag     | Docker |
|------------------------------|----------------------------------------|---------------|--------|
| `app/service`, `app/usecase` | Unit tests with mocks                  | `unit`        | No     |
| `infra/persistence`          | Integration tests with real PostgreSQL | `integration` | Yes    |
| `tests/functional`           | E2E tests with full HTTP server        | `functional`  | Yes    |

### Unit tests

Unit tests use `testify/mock` for repository and service mocks. No external dependencies required.

```bash
make test-unit
# go test ./... -tags=unit -v -count=1
```

### Integration tests

Repository tests use `testcontainers-go` to spin up a `postgres:16-alpine` container. `TestMain` applies migrations from `migrations/*.up.sql` and creates a `bun.DB`. Each test truncates tables via `TRUNCATE` for isolation.

```bash
make test-integration
# go test ./... -tags=integration -v -count=1
```

### Functional tests

Functional (E2E) tests spin up a full HTTP server, PostgreSQL, Redis, and RabbitMQ containers via `testcontainers-go`, and load fixture data via `go-testfixtures`. They send real HTTP requests to all API endpoints.

**Important**: `go-testfixtures` resets ALL PostgreSQL sequences to 10000 but only truncates tables that have fixture files. Any table with SERIAL/BIGSERIAL columns that receives INSERTs during tests must have a fixture file (even an empty `[]`) to ensure it gets truncated between tests. See `tests/functional/testdata/fixtures/outbox.yml`.

```bash
make test-functional
# go test ./tests/functional/... -tags=functional -v -count=1
```

### Run all tests

```bash
make test
# runs test-unit, then test-integration, then test-functional sequentially
```

### Flags

| Flag       | Purpose                                                    |
|------------|------------------------------------------------------------|
| `-tags=`   | Select test group (`unit`, `integration`, or `functional`) |
| `-v`       | Verbose — show each test name and result                   |
| `-count=1` | Disable test caching — always run tests, never use cache   |

---

## Migrations

Database migrations use `bun/migrate` with embedded SQL files.

### Architecture

```
migrations/
├── embed.go                                 # //go:embed *.sql → var Migrations
├── 20250221000001_create_users.up.sql       # CREATE TABLE users
├── 20250221000001_create_users.down.sql     # DROP TABLE users
├── 20250221000002_add_role_to_users.up.sql  # ALTER TABLE ADD COLUMN role
└── 20250221000002_add_role_to_users.down.sql

pkg/migrate/
└── runner.go                             # Runner wraps bun/migrate.Migrator

cmd/migrate/
└── main.go                               # CLI: init, migrate, rollback, status, create
```

`cmd/migrate` is a standalone binary — it initializes only config, logger, and DB (no Wire, no HTTP/gRPC/Redis).

### Usage

First run requires table initialization:
```bash
APP_ENV=local make migrate-init
APP_ENV=local make migrate
```

Creating a new migration:
```bash
APP_ENV=local make migrate-create name=add_posts
# creates migrations/{timestamp}_add_posts.up.sql
# creates migrations/{timestamp}_add_posts.down.sql
```

SQL files in `migrations/` are embedded into the binary via `//go:embed` at compile time.

---

## gRPC

gRPC используется для межсервисного взаимодействия. `.proto` файлы — единственный источник правды для API-контрактов. Из них генерируются Go-клиенты и серверные стабы.

### Структура

```
proto/{subdomain}/{subdomain}.proto   →   gen/{subdomain}/*.pb.go
```

- `proto/` — исходные `.proto` определения, группируются по субдоменам
- `gen/` — сгенерированный код (`make proto`), **не редактировать вручную**

### Правила именования

| Элемент          | Формат                                                  | Пример                                         |
|------------------|---------------------------------------------------------|------------------------------------------------|
| proto package    | `{subdomain}`                                           | `package user;`                                |
| go_package       | `"starter-boilerplate/gen/{subdomain};{subdomain}"`     | `"starter-boilerplate/gen/user;user"`          |
| service          | `{Subdomain}Contract`                                   | `service UserContract`                         |
| rpc              | `{Verb}{Entity}`                                        | `rpc GetUser`                                  |
| request message  | `{RpcName}Request`                                      | `message GetUserRequest`                       |
| response message | `{RpcName}Response`                                     | `message GetUserResponse`                      |

### Добавление нового gRPC сервиса

1. Создать `proto/{name}/{name}.proto`
2. Запустить `make proto` — стабы появятся в `gen/{name}/`
3. Реализовать сгенерированный интерфейс `{Name}ContractServer` в субдомене

---

## Adding a new subdomain

1. Create `internal/{name}/`
2. Mirror the `user` subdomain structure:
   ```
   internal/{name}/
   ├── domain/
   │   ├── model/          # package model — entities
   │   └── repository/     # package repository — interfaces
   ├── app/
   │   ├── service/        # package service — interfaces + implementations
   │   └── usecase/        # package usecase — orchestration logic
   ├── transport/
   │   ├── dto/            # package dto — shared DTOs (domain → transport)
   │   ├── handler/        # package handler — HTTP handlers (one struct per endpoint)
   │   └── contract/       # package contract — gRPC contracts
   ├── infra/
   │   └── persistence/    # package persistence — repository implementation
   ├── initialize.go       # //go:build wireinject — InitializeXxxModule
   └── wire_gen.go         # generated
   ```
3. Declare `InitializeXxxModule` in `internal/{name}/initialize.go` with the required parameters (accept `_ middleware.Init` to ensure middleware ordering)
4. Add `{name}.InitializeXxxModule` to `wire.Build` in `internal/initialize.go`
5. Add `_ {name}.Module` parameter to `newApp` to guarantee initialization
6. If the package has multiple providers, export a `ProviderSet` in `wire.go`
7. Run `make wire`
