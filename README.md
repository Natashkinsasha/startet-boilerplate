# starter-boilerplate

Go starter project for bootstrapping new services.

---

## Stack

| Component      | Library                               |
|----------------|---------------------------------------|
| HTTP server    | `net/http` (stdlib)                   |
| OpenAPI / REST | `github.com/danielgtaylor/huma/v2`    |
| ORM            | `github.com/uptrace/bun` (PostgreSQL) |
| Cache          | `github.com/redis/go-redis/v9`        |
| Configuration  | `gopkg.in/yaml.v3`                    |
| Migrations     | `bun/migrate`                         |
| Logging        | `go.uber.org/zap`                     |
| Authentication | `github.com/golang-jwt/jwt/v5`        |
| gRPC           | `google.golang.org/grpc` + `protobuf` |
| DI             | `github.com/google/wire`              |
| Testing        | `github.com/testcontainers/testcontainers-go` |
| Infrastructure | Docker + docker-compose               |

---

## Project layout

```
starter-boilerplate/
├── cmd/
│   ├── api/
│   │   └── main.go              # entry point: signal → InitializeApp → app.Run
│   ├── migrate/
│   │   └── main.go              # DB migration CLI (init, migrate, rollback, status, create)
│   └── swagger/
│       └── main.go              # OpenAPI spec generation
│
├── internal/
│   ├── initialize.go        # Wire injector (//go:build wireinject)
│   ├── wire_gen.go          # generated by: wire gen ./...
│   ├── shared/              # infrastructure reused across all subdomains
│   │   ├── app/
│   │   │   └── app.go       # App struct, New(), Run(), shutdown()
│   │   ├── config/
│   │   │   └── setup.go     # SetupConfig() → *Config; assembles Config from sub-pkg types
│   │   ├── db/
│   │   │   └── setup.go     # DBConfig; Setup(DBConfig, *zap.Logger) → *bun.DB
│   │   ├── redis/
│   │   │   └── setup.go     # RedisConfig; Setup(RedisConfig, *zap.Logger) → *goredis.Client
│   │   ├── server/
│   │   │   └── setup.go     # SetupMux() → *http.ServeMux; SetupHTTPServer() → *http.Server
│   │   ├── huma/
│   │   │   ├── setup.go     # Setup(*http.ServeMux, AppConfig) → huma.API
│   │   │   └── spec.go      # GenerateSpecFile(huma.API) — writes docs/swagger.json
│   │   ├── middleware/
│   │   │   ├── setup.go     # Setup(*http.Server, huma.API, *jwt.Manager) → Init
│   │   │   ├── auth.go      # NewAuthMiddleware — Bearer token validation
│   │   │   ├── role.go      # NewRoleMiddleware — role-based access control
│   │   │   ├── limiter.go   # NewLimiterMiddleware — per-IP rate limiting
│   │   │   ├── logger.go    # newLoggerMiddleware — request logging
│   │   │   └── requestid.go # NewRequestIDMiddleware — X-Request-ID header
│   │   ├── logger/
│   │   │   └── logger.go    # LoggerConfig; SetupLogger(LoggerConfig) → *zap.Logger
│   │   ├── jwt/
│   │   │   └── jwt.go       # JWTConfig; NewJWTManager(JWTConfig) → *pkgjwt.Manager
│   │   ├── grpc/
│   │   │   └── setup.go     # GRPCConfig; Setup(GRPCConfig, *zap.Logger) → *grpc.Server
│   │   └── migrate/
│   │       └── runner.go    # Runner; wraps bun/migrate.Migrator
│   │
│   └── user/                # subdomain (user + auth combined)
│       ├── domain/
│       │   ├── model/
│       │   │   └── user.go          # User, TokenPair, Role
│       │   └── repository/
│       │       └── user.go          # UserRepository (interface)
│       ├── app/
│       │   ├── service/
│       │   │   ├── user.go          # UserService interface + impl
│       │   │   └── token.go         # TokenService interface + impl
│       │   └── usecase/
│       │       ├── login.go         # LoginUseCase — orchestrates login flow
│       │       └── refresh.go       # RefreshUseCase — orchestrates token refresh
│       ├── transport/
│       │   ├── dto/
│       │   │   └── user.go          # UserDTO, TokenPairDTO — shared across HTTP & gRPC
│       │   ├── handler/
│       │   │   ├── setup.go         # SetupHandlers() — registers all HTTP routes
│       │   │   ├── login.go         # LoginHandler (POST /api/v1/auth/login)
│       │   │   ├── refresh.go       # RefreshHandler (POST /api/v1/auth/refresh)
│       │   │   ├── get_user.go      # GetUserHandler (GET /api/v1/users/{id})
│       │   │   └── types.go         # tokenOutput
│       │   └── contract/
│       │       └── user.go          # gRPC Contract, SetupUserContract(), GetUser()
│       ├── infra/
│       │   └── persistence/
│       │       └── user.go          # userRepository — implements UserRepository
│       ├── initialize.go            # Wire injector: Module, InitializeUserModule
│       └── wire_gen.go              # generated
│
├── pkg/                     # reusable code, no dependency on internal/
│   ├── jwt/
│   │   └── manager.go       # Manager, Claims, Config; token generation and validation
│   ├── logger/
│   │   └── setup.go         # Logger (= zap.Logger); SetupLogger(format, level, stacktraceLevel); NewNop()
│   └── testcontainer/
│       ├── setup.go          # TestMain-level setup helpers
│       ├── container.go      # Container interface
│       ├── container_manager.go # ContainerManager — lifecycle management
│       ├── pg_container.go   # PostgreSQL testcontainer
│       └── redis_container.go # Redis testcontainer
│
├── proto/                   # Protobuf definitions (.proto files)
├── gen/                     # generated code from proto (DO NOT edit)
├── migrations/              # SQL migrations (bun/migrate)
│   ├── embed.go             # //go:embed *.sql → var Migrations
│   └── *.sql                # {timestamp}_{name}.up.sql / .down.sql
├── tests/
│   ├── functional/
│   │   ├── api_test.go      # E2E tests — API endpoints
│   │   ├── auth_test.go     # E2E tests — auth flow
│   │   ├── user_test.go     # E2E tests — user endpoints
│   │   └── testdata/fixtures/users.yml
│   └── suite/
│       └── functional_suite.go  # shared test suite setup
├── env/
│   ├── .env.yaml            # base values
│   ├── .env.{APP_ENV}.yaml  # environment override (loaded if APP_ENV is set)
│   ├── .env.standalone.yaml # standalone mode (DB/Redis disabled)
│   └── .env.test.yaml       # test environment config
├── docker-compose.yml
├── Makefile
└── go.mod                   # module: starter-boilerplate
```

---

## Architectural rules

### Subdomain layers

```
transport/handler  →  app/usecase  →  app/service  ←  infra/persistence
        ↓                  ↓               ↓                   ↓
   domain/repository  (interfaces)    domain/model (entities)
```

| Layer             | Package                | Depends on                                         |
|-------------------|------------------------|----------------------------------------------------|
| Entities / DTOs   | `domain/model`         | nothing external                                   |
| Interfaces        | `domain/repository`    | `domain/model`                                     |
| Services          | `app/service`          | `domain/repository`, `domain/model`, `pkg/jwt`     |
| Use cases         | `app/usecase`          | `app/service`, `domain/model`                      |
| Transport DTOs    | `transport/dto`        | `domain/model`                                     |
| HTTP handlers     | `transport/handler`    | `app/usecase`, `app/service`, `transport/dto`      |
| gRPC contracts    | `transport/contract`   | `domain/repository`, `transport/dto`               |
| Repository impl   | `infra/persistence`    | `domain/repository`, `domain/model`, `bun`         |

### Package naming

Each package is named after its directory — no aliases needed:

```
internal/user/domain/model/            → package model
internal/user/domain/repository/       → package repository
internal/user/app/service/             → package service
internal/user/app/usecase/             → package usecase
internal/user/transport/dto/           → package dto
internal/user/transport/handler/       → package handler
internal/user/transport/contract/      → package contract
internal/user/infra/persistence/       → package persistence
```

```go
import (
    "starter-boilerplate/internal/user/domain/model"
    "starter-boilerplate/internal/user/domain/repository"
    "starter-boilerplate/internal/user/app/service"
    "starter-boilerplate/internal/user/app/usecase"
    "starter-boilerplate/internal/user/infra/persistence"
)
```

### Function naming

| Prefix               | Purpose                                          | Returns error     |
|----------------------|--------------------------------------------------|-------------------|
| `New...`             | Pure constructor, only creates an object         | yes, if needed    |
| `Setup...`           | Creates object + invokes methods (side effects)  | **no — panic**    |
| `Initialize...Module`| Wire injector — wires subdomain dependencies     | no                |

**`Setup*` never returns an error** — on critical failure it calls `panic`.

### Visibility (exported / unexported)

Repository implementations in `infra/` are **unexported**:
```go
type userRepository struct{ db *bun.DB }  // infra/persistence
```

Service implementations are **unexported**, interfaces are **exported**:
```go
type UserService interface { ... }     // exported interface
type userService struct{ ... }         // unexported implementation
```

Constructors (`New...`) are **exported** — required by Wire.

Internal helpers and types are **unexported**:
```go
func (d DBConfig) dsn() string { ... }  // used only inside db/setup.go
type tokenType string                    // used only inside pkg/jwt
```

### Handlers

Each handler is a separate struct in the `transport/handler/` package.
One file = one endpoint (input type, handler struct, registration, handler method).

`SetupHandlers(api, ...)` accepts all handlers and registers their routes:
```go
// setup.go
func SetupHandlers(api huma.API, loginH *LoginHandler, refreshH *RefreshHandler, getUserH *GetUserHandler) HandlersInit {
    loginH.Register(api)
    refreshH.Register(api)
    getUserH.Register(api)
    return HandlersInit{}
}

// login.go
type LoginHandler struct {
    loginUC *usecase.LoginUseCase
}

func NewLoginHandler(loginUC *usecase.LoginUseCase) *LoginHandler

func (h *LoginHandler) Register(api huma.API) {
    huma.Register(api, huma.Operation{...}, h.handle)
}

func (h *LoginHandler) handle(ctx context.Context, input *loginInput) (*tokenOutput, error) { ... }
```
Handler methods (`handle`) are **unexported**. Each handler has an exported `Register` method.

---

## Configuration

### Principle: config lives next to its tool

Each `internal/shared/*` package defines its **own** config type. `config/setup.go` reads YAML files and assembles the root `*Config`.

```
internal/shared/db/setup.go      → type DBConfig struct
internal/shared/redis/setup.go   → type RedisConfig struct
internal/shared/jwt/jwt.go       → type JWTConfig struct
internal/shared/logger/logger.go → type LoggerConfig struct
internal/shared/grpc/setup.go    → type GRPCConfig struct
internal/shared/config/setup.go  → type Config struct  (aggregates all)
```

Dependency direction:
```
config  →  db, redis, jwt, logger, grpc    (config imports them, not the other way around)
```

### Structs

```go
// internal/shared/config/setup.go
type AppConfig struct {
    Port            int           `yaml:"port" validate:"required"`
    ReadTimeout     time.Duration `yaml:"read_timeout" validate:"required"`
    WriteTimeout    time.Duration `yaml:"write_timeout" validate:"required"`
    IdleTimeout     time.Duration `yaml:"idle_timeout" validate:"required"`
    ShutdownTimeout time.Duration `yaml:"shutdown_timeout" validate:"required"`
    SwaggerDocs     bool          `yaml:"swagger_docs"`
    SwaggerFile     bool          `yaml:"swagger_file"`
}

type Config struct {
    App    AppConfig
    Logger sharedlogger.LoggerConfig
    DB     shareddb.DBConfig
    Redis  sharedredis.RedisConfig
    JWT    sharedjwt.JWTConfig
    GRPC   sharedgrpc.GRPCConfig
}
```

```go
// internal/shared/db/setup.go
type DBConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Host           string        `yaml:"host" validate:"required_unless=Standalone true"`
    Port           int           `yaml:"port" validate:"required_unless=Standalone true"`
    Name           string        `yaml:"name" validate:"required_unless=Standalone true"`
    User           string        `yaml:"user" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password" validate:"required_unless=Standalone true"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// internal/shared/redis/setup.go
type RedisConfig struct {
    Standalone     bool          `yaml:"standalone"`
    Addr           string        `yaml:"addr" validate:"required_unless=Standalone true"`
    Password       string        `yaml:"password"`
    DB             int           `yaml:"db"`
    ConnectTimeout time.Duration `yaml:"connect_timeout" validate:"required_unless=Standalone true"`
}
```

```go
// internal/shared/jwt/jwt.go
type JWTConfig struct {
    AccessSecret  string        `yaml:"access_secret" validate:"required"`
    RefreshSecret string        `yaml:"refresh_secret" validate:"required"`
    AccessTTL     time.Duration `yaml:"access_ttl" validate:"required"`
    RefreshTTL    time.Duration `yaml:"refresh_ttl" validate:"required"`
}
```

```go
// internal/shared/logger/logger.go
type LoggerConfig struct {
    Format          string `yaml:"format"`           // "json" | "console"
    Level           string `yaml:"level"`            // "debug" | "info" | "warn" | "error"
    StacktraceLevel string `yaml:"stacktrace_level"` // "debug" | "info" | "warn" | "error" | "off"
}
```

```go
// internal/shared/grpc/setup.go
type GRPCConfig struct {
    Port int `yaml:"port" validate:"required"`
}
```

When `Standalone: true`, DB/Redis connections are skipped and their fields are not validated. This allows running commands like `cmd/swagger` without a running database.

### Loading order

- `APP_ENV` is read **only** from the OS environment variable
- Config files are YAML:
  1. `env/.env.yaml` — base values (always loaded)
  2. `env/.env.{APP_ENV}.yaml` — override (applied only if `APP_ENV` is set)
- Later values override earlier ones (YAML merge)

### Example YAML config

```yaml
# env/.env.yaml (base)
app:
  port: 8080
  read_timeout: 5s
  write_timeout: 10s
  idle_timeout: 120s
  shutdown_timeout: 10s

logger:
  format: console
  level: info

jwt:
  access_secret: change-me
  refresh_secret: change-me
  access_ttl: 15m
  refresh_ttl: 168h
```

```yaml
# env/.env.local.yaml (APP_ENV=local)
db:
  host: localhost
  port: 5432
  name: starter
  user: postgres
  password: postgres
  connect_timeout: 5s

redis:
  addr: localhost:6379
  password: ""
  db: 0
  connect_timeout: 5s
```

If `logger.level` is missing or invalid, the format default is used:
- `console` → `debug`
- `json` → `info`

---

## Wire — DI pattern

### Application level (`internal/initialize.go`)

```go
//go:build wireinject

package internal

func newApp(httpSrv *http.Server, cfg *config.Config, _ user.Module, _ *zap.Logger, _ *goredis.Client, grpcSrv *gogrpc.Server, api gohuma.API) *app.App {
    return app.New(httpSrv, cfg, grpcSrv, api)
}

func InitializeApp(ctx context.Context) *app.App {
    wire.Build(
        config.SetupConfig,
        logger.SetupLogger,
        wire.FieldsOf(new(*config.Config), "App", "Logger", "DB", "JWT", "Redis", "GRPC"),
        db.Setup,
        redis.Setup,
        server.SetupMux,
        server.SetupHTTPServer,
        huma.Setup,
        sharedgrpc.Setup,
        sharedjwt.NewJWTManager,
        middleware.Setup,

        user.InitializeUserModule,

        newApp,
    )
    return nil
}
```

`newApp` is a thin Wire wrapper — it accepts unused dependencies (`_ user.Module`, `_ *zap.Logger`, `_ *goredis.Client`) to force Wire to create them (side-effect ordering), then delegates to `app.New` with only the needed parameters.

`wire.FieldsOf` extracts fields from `*Config` and exposes them as individual providers.

`db.Setup`, `redis.Setup`, `sharedgrpc.Setup` accept `*zap.Logger` as a parameter to ensure Wire initializes the logger first.

`InitializeApp(ctx)` accepts a context — propagated to `db.Setup` and `redis.Setup` for connection timeouts.

### Subdomain level (`internal/user/initialize.go`)

```go
//go:build wireinject

package user

type Module struct{} // Wire marker: all handlers have been set up

func NewModule(_ handler.HandlersInit, _ usercontract.Init) Module {
    return Module{}
}

func InitializeUserModule(db *bun.DB, api huma.API, grpcSrv *gogrpc.Server, jwtManager *pkgjwt.Manager, _ sharedmw.Init) Module {
    wire.Build(
        persistence.NewUserRepository,
        service.NewUserService,
        service.NewTokenService,
        usecase.NewLoginUseCase,
        usecase.NewRefreshUseCase,
        handler.NewLoginHandler,
        handler.NewRefreshHandler,
        handler.NewGetUserHandler,
        handler.SetupHandlers,
        usercontract.SetupUserContract,
        NewModule,
    )
    return Module{}
}
```

`NewModule` is a Wire dependency sink — it ensures all handlers and contracts are created. `SetupHandlers` and `SetupUserContract` register routes during construction.

`InitializeUserModule` accepts `_ sharedmw.Init` to guarantee middleware is installed before handlers are registered.

### Code generation

```bash
make wire   # wire gen ./...
```

Two files are generated:
- `internal/user/wire_gen.go` — implementation of `InitializeUserModule`
- `internal/wire_gen.go` — implementation of `InitializeApp`

Both carry the `//go:build !wireinject` tag and **must not be edited manually**.

---

## pkg/jwt

Low-level JWT package. Has no dependency on `internal/`.

```go
// pkg/jwt/manager.go

type Config struct {
    AccessSecret  string
    RefreshSecret string
    AccessTTL     time.Duration
    RefreshTTL    time.Duration
}

type Claims struct {
    UserID    string    `json:"user_id"`
    Role      string    `json:"role"`
    TokenType tokenType `json:"token_type"` // unexported type — internal detail
    jwt.RegisteredClaims
}

type Manager struct{ cfg Config }

func NewManager(cfg Config) *Manager

// Generation
func (m *Manager) GenerateAccessToken(userID, role string) (string, error)
func (m *Manager) GenerateRefreshToken(userID, role string) (string, error)

// Validation
func (m *Manager) ValidateAccessToken(tokenStr string) (*Claims, error)
func (m *Manager) ValidateRefreshToken(tokenStr string) (*Claims, error)
```

Internal details (`tokenType`, constants `accessToken`/`refreshToken`) are unexported.
The public API is limited to `Manager`, `Claims`, `Config`, and their methods.

---

## pkg/logger

Thin wrapper over `go.uber.org/zap`.

```go
type Logger = zap.Logger  // type alias, not a new type

func SetupLogger(format, level, stacktraceLevel string) *Logger
func NewNop() *Logger  // for tests
```

`format` behaviour:
- `"json"` → `zap.NewProductionConfig()` (default level: `info`)
- anything else → `zap.NewDevelopmentConfig()` with colour output (default level: `debug`)

`level` overrides the format default. An invalid value is silently ignored.

`stacktraceLevel` controls which log levels include stacktraces:
- `"off"` → disables stacktraces entirely
- `""` (empty) → keeps format defaults
- `"warn"`, `"error"`, etc. → sets custom stacktrace threshold

---

## Subdomain: user

### domain/model

```go
// internal/user/domain/model/user.go
package model

type Role string

const (
    RoleUser  Role = "user"
    RoleAdmin Role = "admin"
)

type User struct {
    ID           string
    Email        string
    PasswordHash string
    Role         Role
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type TokenPair struct {
    AccessToken  string
    RefreshToken string
}
```

### domain/repository

```go
// internal/user/domain/repository/user.go
package repository

type UserRepository interface {
    FindByID(ctx context.Context, id string) (*model.User, error)
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    Create(ctx context.Context, user *model.User) error
    Update(ctx context.Context, user *model.User) error
}
```

### app/service

Two interfaces, each with an unexported implementation:

```go
// internal/user/app/service/user.go
package service

type UserService interface {
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    FindByID(ctx context.Context, id string) (*model.User, error)
    CheckPassword(passwordHash, password string) error
}

func NewUserService(userRepo repository.UserRepository) UserService
```

```go
// internal/user/app/service/token.go
package service

type TokenService interface {
    IssueTokenPair(userID, role string) (*model.TokenPair, error)
    ValidateRefreshToken(token string) (*jwt.Claims, error)
}

func NewTokenService(jwtManager *jwt.Manager) TokenService
```

### app/usecase

Use cases orchestrate services. Each use case is a single-purpose struct with an `Execute` method.

```go
// internal/user/app/usecase/login.go
package usecase

type LoginUseCase struct {
    userService  service.UserService
    tokenService service.TokenService
}

func NewLoginUseCase(us service.UserService, ts service.TokenService) *LoginUseCase
```

`Execute(ctx, email, password)` flow:
1. `userService.FindByEmail(ctx, email)` — find user
2. `userService.CheckPassword(passwordHash, password)` — verify password via bcrypt
3. `tokenService.IssueTokenPair(userID, role)` — generate access + refresh tokens

```go
// internal/user/app/usecase/refresh.go
package usecase

type RefreshUseCase struct {
    userService  service.UserService
    tokenService service.TokenService
}

func NewRefreshUseCase(us service.UserService, ts service.TokenService) *RefreshUseCase
```

`Execute(ctx, refreshToken)` flow:
1. `tokenService.ValidateRefreshToken(refreshToken)` — validate and extract claims
2. `userService.FindByID(ctx, claims.UserID)` — verify user still exists
3. `tokenService.IssueTokenPair(userID, role)` — issue new token pair

### infra/persistence

```go
// internal/user/infra/persistence/user.go
package persistence

type userModel struct {            // unexported, bun ORM model
    bun.BaseModel `bun:"table:users"`
    ID           string `bun:"id,pk"`
    Email        string `bun:"email,unique,notnull"`
    PasswordHash string `bun:"password_hash,notnull"`
    Role         string `bun:"role,notnull,default:'user'"`
    CreatedAt    int64  `bun:"created_at,notnull"`
    UpdatedAt    int64  `bun:"updated_at,notnull"`
}

type userRepository struct{ db *bun.DB }  // unexported

func NewUserRepository(db *bun.DB) repository.UserRepository
```

### transport/dto

Stateless data-transfer package shared by HTTP handlers and gRPC contracts. Converts domain models to transport representations. Carries JSON tags so both layers can use the same types directly.

```go
// user.go
package dto

type UserDTO struct {
    ID    string `json:"id"`
    Email string `json:"email"`
    Role  string `json:"role"`
}

type TokenPairDTO struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
}

func NewUserDTO(u *model.User) UserDTO
func NewTokenPairDTO(tp *model.TokenPair) TokenPairDTO
```

### transport/handler

```go
// setup.go
package handler

type HandlersInit struct{}

func SetupHandlers(api huma.API, loginH *LoginHandler, refreshH *RefreshHandler, getUserH *GetUserHandler) HandlersInit

// login.go   — LoginHandler, NewLoginHandler(), Register(api), handle(ctx, *loginInput)
// refresh.go — RefreshHandler, NewRefreshHandler(), Register(api), handle(ctx, *refreshInput)
// get_user.go — GetUserHandler, NewGetUserHandler(), Register(api), handle(ctx, *getUserInput)
// types.go   — tokenOutput (uses dto.TokenPairDTO as Body)
```

### transport/contract

```go
// user.go
package contract

type Contract struct {
    gen.UnimplementedUserContractServer
    ur repository.UserRepository
}

type Init struct{}

func SetupUserContract(grpcSrv *grpc.Server, ur repository.UserRepository) Init

// GetUser(ctx, *gen.GetUserRequest) (*gen.GetUserResponse, error)
// Uses dto.NewUserDTO() then maps DTO → protobuf
```

### HTTP endpoints

```
POST /api/v1/auth/login
  Body:     { "email": string (format: email), "password": string (minLength: 6) }
  Response: { "access_token": string, "refresh_token": string }

POST /api/v1/auth/refresh
  Body:     { "refresh_token": string }
  Response: { "access_token": string, "refresh_token": string }

GET /api/v1/users/{id}
  Headers:  Authorization: Bearer <access_token>
  Response: { "user": { "id": string, "email": string, "role": string } }
  Notes:    Admins can access any user; non-admins can only access their own profile
```

---

## Middleware

Middleware is installed in `internal/shared/middleware/setup.go` in two layers:

**Huma-level** (applied per-operation, outermost first):
1. `RequestID` — generates/propagates `X-Request-ID` header
2. `Logger` — logs request method, path, status, duration
3. `Limiter` — per-IP rate limiting (100 req/min)
4. `Auth` — validates Bearer token on endpoints with `bearerAuth` security
5. `Role` — checks `requiredRoles` metadata on operations

**HTTP-level** (wraps the entire `http.Handler`):
- `WithCORS` — permissive CORS headers
- `WithRecover` — panic recovery, returns 500 JSON

---

## cmd/api/main.go

```go
func main() {
    ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
    defer stop()

    app := internal.InitializeApp(ctx)

    if err := app.Run(ctx); err != nil {
        zap.L().Fatal("server error", zap.Error(err))
    }
}
```

`app.Run(ctx)` starts HTTP and gRPC servers via `errgroup` and blocks until context cancellation. On shutdown it gracefully stops both servers in parallel with a configurable timeout (`ShutdownTimeout`).

---

## docker-compose.yml

Starts two services, both with healthchecks:

| Service    | Image                | Port   | Volume          |
|------------|----------------------|--------|-----------------|
| `postgres` | `postgres:16-alpine` | `5432` | `postgres_data` |
| `redis`    | `redis:7-alpine`     | `6379` | `redis_data`    |

`DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_PORT` are read from the environment
(defaults: `starter`, `postgres`, `postgres`, `5432`).

---

## Commands

```bash
make local-run        # APP_ENV=local go run ./cmd/api/...
make dev              # air (live reload)
make build            # go build -o bin/api ./cmd/api/...
make wire             # wire gen ./...
make swagger          # APP_ENV=standalone go run ./cmd/swagger/...
make proto            # generate Go code from .proto files
make lint             # golangci-lint run ./...
make vet              # go vet with all build tags
make deps             # go mod tidy
make install-tools    # install wire, protoc-gen-go, golangci-lint, air
make docker-up        # docker-compose up -d
make docker-down      # docker-compose down
make test-unit        # unit tests only
make test-integration # integration tests (requires Docker)
make test-functional  # functional E2E tests (requires Docker)
make test             # run all: unit, integration, functional

# Migrations (require APP_ENV with DB config, e.g. APP_ENV=local)
make migrate          # apply pending migrations
make migrate-init     # create bun_migrations / bun_migration_locks tables
make migrate-rollback # rollback last migration group
make migrate-status   # show migration status
make migrate-create name=<name>  # create new .up.sql / .down.sql files
```

---

## Testing

### Build tags

All test files have a build tag — `//go:build unit` or `//go:build integration`. This means `go test ./...` without an explicit `-tags` flag runs **no tests**. Use the Makefile targets below.

### Strategy

| Layer                        | Approach                               | Build tag     | Docker |
|------------------------------|----------------------------------------|---------------|--------|
| `app/service`, `app/usecase` | Unit tests with mocks                  | `unit`        | No     |
| `infra/persistence`          | Integration tests with real PostgreSQL | `integration` | Yes    |
| `tests/functional`           | E2E tests with full HTTP server        | `functional`  | Yes    |

### Unit tests

Unit tests use `testify/mock` for repository and service mocks. No external dependencies required.

```bash
make test-unit
# go test ./... -tags=unit -v -count=1
```

### Integration tests

Repository tests use `testcontainers-go` to spin up a `postgres:16-alpine` container. `TestMain` applies migrations from `migrations/*.up.sql` and creates a `bun.DB`. Each test truncates tables via `TRUNCATE` for isolation.

```bash
make test-integration
# go test ./... -tags=integration -v -count=1
```

### Functional tests

Functional (E2E) tests spin up a full HTTP server with `httptest`, a PostgreSQL container via `testcontainers-go`, and load fixture data via `go-testfixtures`. They send real HTTP requests to all API endpoints.

```bash
make test-functional
# go test ./tests/functional/... -tags=functional -v -count=1
```

### Run all tests

```bash
make test
# runs test-unit, then test-integration, then test-functional sequentially
```

### Flags

| Flag       | Purpose                                                    |
|------------|------------------------------------------------------------|
| `-tags=`   | Select test group (`unit`, `integration`, or `functional`) |
| `-v`       | Verbose — show each test name and result                   |
| `-count=1` | Disable test caching — always run tests, never use cache   |

---

## Migrations

Database migrations use `bun/migrate` with embedded SQL files.

### Architecture

```
migrations/
├── embed.go                                 # //go:embed *.sql → var Migrations
├── 20250221000001_create_users.up.sql       # CREATE TABLE users
├── 20250221000001_create_users.down.sql     # DROP TABLE users
├── 20250221000002_add_role_to_users.up.sql  # ALTER TABLE ADD COLUMN role
└── 20250221000002_add_role_to_users.down.sql

internal/shared/migrate/
└── runner.go                             # Runner wraps bun/migrate.Migrator

cmd/migrate/
└── main.go                               # CLI: init, migrate, rollback, status, create
```

`cmd/migrate` is a standalone binary — it initializes only config, logger, and DB (no Wire, no HTTP/gRPC/Redis).

### Usage

First run requires table initialization:
```bash
APP_ENV=local make migrate-init
APP_ENV=local make migrate
```

Creating a new migration:
```bash
APP_ENV=local make migrate-create name=add_posts
# creates migrations/{timestamp}_add_posts.up.sql
# creates migrations/{timestamp}_add_posts.down.sql
```

SQL files in `migrations/` are embedded into the binary via `//go:embed` at compile time.

---

## gRPC

gRPC используется для межсервисного взаимодействия. `.proto` файлы — единственный источник правды для API-контрактов. Из них генерируются Go-клиенты и серверные стабы.

### Структура

```
proto/{subdomain}/{subdomain}.proto   →   gen/{subdomain}/*.pb.go
```

- `proto/` — исходные `.proto` определения, группируются по субдоменам
- `gen/` — сгенерированный код (`make proto`), **не редактировать вручную**

### Правила именования

| Элемент          | Формат                                                  | Пример                                         |
|------------------|---------------------------------------------------------|------------------------------------------------|
| proto package    | `{subdomain}`                                           | `package user;`                                |
| go_package       | `"starter-boilerplate/gen/{subdomain};{subdomain}"`     | `"starter-boilerplate/gen/user;user"`          |
| service          | `{Subdomain}Contract`                                   | `service UserContract`                         |
| rpc              | `{Verb}{Entity}`                                        | `rpc GetUser`                                  |
| request message  | `{RpcName}Request`                                      | `message GetUserRequest`                       |
| response message | `{RpcName}Response`                                     | `message GetUserResponse`                      |

### Добавление нового gRPC сервиса

1. Создать `proto/{name}/{name}.proto`
2. Запустить `make proto` — стабы появятся в `gen/{name}/`
3. Реализовать сгенерированный интерфейс `{Name}ContractServer` в субдомене

---

## Adding a new subdomain

1. Create `internal/{name}/`
2. Mirror the `user` subdomain structure:
   ```
   internal/{name}/
   ├── domain/
   │   ├── model/          # package model — entities
   │   └── repository/     # package repository — interfaces
   ├── app/
   │   ├── service/        # package service — interfaces + implementations
   │   └── usecase/        # package usecase — orchestration logic
   ├── transport/
   │   ├── dto/            # package dto — shared DTOs (domain → transport)
   │   ├── handler/        # package handler — HTTP handlers (one struct per endpoint)
   │   └── contract/       # package contract — gRPC contracts
   ├── infra/
   │   └── persistence/    # package persistence — repository implementation
   ├── initialize.go       # //go:build wireinject — InitializeXxxModule
   └── wire_gen.go         # generated
   ```
3. Declare `InitializeXxxModule` in `internal/{name}/initialize.go` with the required parameters
4. Add `{name}.InitializeXxxModule` to `wire.Build` in `internal/initialize.go`
5. Add `_ {name}.Module` parameter to `newApp` to guarantee initialization
6. Run `make wire`
